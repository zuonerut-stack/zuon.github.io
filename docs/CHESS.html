<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess Study v1.2</title>
<style>
:root{

  --board-size:min(100vh,100vw);
  --square-size: calc(var(--board-size) / 8);
}
body{font-family: Inter, system-ui, Arial; background:#f2efe9; margin:20px; color:#222}
.app{display:flex;gap:24px;align-items:flex-start}
.board-wrap{background:linear-gradient(180deg,#e6d9c3,#d7c4a6);padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.12)}
.board{aspect-ratio: 1 / 1;
  width: --board-size;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows: repeat(8, 1fr);border-radius:6px;overflow:hidden;position:relative}
.square{width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:30px;user-select:none}
.square.light{background:linear-gradient(180deg,#fdf5e9,#f7e9d1)}
.square.dark{background:linear-gradient(180deg,#c49663,#8f5b33)}
.square.highlight{outline:4px solid rgba(255,255,0,0.45);box-sizing:border-box}
.square.last-move{box-shadow:inset 0 0 40px rgba(255,255,255,0.06)}
.coords{position:absolute;left:6px;top:6px;font-size:12px;color:rgba(0,0,0,0.45)}
.controls{width:420px}
.controls .panel{background:white;padding:12px;border-radius:10px;box-shadow:0 6px 14px rgba(0,0,0,0.06);margin-bottom:12px}
.btn{display:inline-block;padding:8px 12px;border-radius:8px;background:#2b6cb0;color:white;text-decoration:none;cursor:pointer}
.btn.secondary{background:#718096}
.piece {
  font-size: min(10vw, 48px);
  line-height: 1;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:grab;
}
.row{display:flex;gap:8px;align-items:center}
.meta{font-size:13px;color:#444}
.moves-list{max-height:140px;overflow:auto;padding:8px;border-radius:8px;background:#fbfbfb}
.board-options{display:flex;gap:8px;margin-bottom:8px}
.save-stage{background:#ffffff;padding:10px;border-radius:10px;min-height:220px}
.save-item{background:#f7f7f8;padding:8px;border-radius:8px;margin:6px;display:inline-block;cursor:grab}
.save-toolbar{display:flex;gap:8px;flex-wrap:wrap}
.save-canvas{position:relative;width:100%;height:260px;border-radius:8px;background:linear-gradient(180deg,#fffafa,#f6fcff);overflow:auto}
.node{position:absolute;padding:8px 10px;border-radius:8px;background:#fff;border:1px solid #ddd;box-shadow:0 6px 12px rgba(0,0,0,0.06);cursor:grab}
.node .title{font-weight:600;font-size:13px}
.node { position:absolute;padding:6px;border-radius:8px;background:#fff;border:1px solid #ddd;box-shadow:0 6px 12px rgba(0,0,0,0.06);cursor:grab; width:120px; height:100px; display:flex; align-items:center; justify-content:center; }
.node .mini-board{ width:100px; height:84px; display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr); border-radius:6px; overflow:hidden; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.02); }
.node .mini-square{ font-size:10px; display:flex; align-items:center; justify-content:center; line-height:1; user-select:none; }
.node .mini-square.light{ background:#f5efe1; }
.node .mini-square.dark{ background:#d2b79b; }
.node.base-selected{ outline:3px solid #ff9f43; box-sizing:border-box; }
.node small{display:block;color:#666;margin-top:4px}
svg.connections{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
.notice{font-size:13px;color:#666}
.promotion-modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:white;padding:14px;border-radius:10px;box-shadow:0 20px 50px rgba(0,0,0,0.2)}
.promotion-modal button{margin:6px}
.footer{font-size:12px;color:#666;margin-top:8px}
</style>
</head>
<body>
<div class="app">
  <div class="board-wrap">
    <div class="coords">a1 - h8 (drag pieces or click)</div>
    <div id="board" class="board"></div>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:space-between;align-items:center">
      <div class="meta"><span id="turnLabel">White to move</span> • <span id="statusLabel">Ready</span></div>
      <div>
        <button class="btn" id="undoBtn">Undo</button>
        <button class="btn secondary" id="resetBtn">Reset</button>
      </div>
    </div>
  </div>
  <div class="controls">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="font-weight:700">Game Controls</div>
        <div class="notice">Board style: wooden (editable in CSS). You can switch background image with the 'Upload' control later.</div>
      </div>
      <div class="row board-options">
        <label><input type="checkbox" id="legalOnly" checked> Enforce legal moves</label>
        <label><input type="checkbox" id="showCoords" checked> Show coords</label>
      </div>
      <div style="margin-top:8px" class="row">
        <div class="moves-list" id="movesList">Moves will appear here.</div>
      </div>
    </div>

    <div class="panel save-stage">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">Save & Lines (Snapshots)</div>
        <div class="save-toolbar">
          <button class="btn" id="saveBtn">Save Snapshot</button>
          <button class="btn secondary" id="clearSaves">Clear Saves</button>
        </div>
      </div>
      <div style="margin-top:8px" class="save-canvas" id="saveCanvas">
        <svg class="connections" id="connections"></svg>
      </div>
      <div style="margin-top:8px">
        <div class="notice">Click a node to load that snapshot. Drag nodes to arrange. Select a node and press 'Link to Selected' on another node to connect them (form strategy lines).</div>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px">
  <button class="btn" id="selectAsBaseBtn">Select as base</button>
  <button class="btn secondary" id="clearBaseBtn">Clear base</button>
  <button class="btn secondary" id="deleteNodeBtn">Delete Selected Node (and descendants)</button>
  <div style="flex:1"></div>
</div>
    </div>

    <div class="panel">
      <div style="font-weight:700;margin-bottom:6px">Help</div>
      <div class="meta">This is a single-file HTML project that implements a chess board with legal move enforcement (including pins and checks), en passant, castling both sides, promotion, and a snapshot/graph system to save positions and connect them into lines.</div>
      <div class="footer">Tips: Save positions frequently. Use labels to create lines (openings, tactical motifs).</div>
    </div>
  </div>
</div>

<div id="promotionModal" class="promotion-modal" style="display:none">
  <div style="font-weight:700;margin-bottom:8px">Choose promotion piece</div>
  <div id="promoButtons"></div>
  <div style="text-align:right;margin-top:8px"><button class="btn secondary" id="promoCancel">Cancel</button></div>
</div>

<script>
/*
  Single-file chess implementation with:
  - move generation + legality (pins, checks)
  - en passant
  - castling (kingside + queenside)
  - promotion UI
  - save/recall snapshots (FEN-like) with a draggable node graph + connections
*/

// --- Utilities
const PIECES = { p:'pawn', r:'rook', n:'knight', b:'bishop', q:'queen', k:'king' };
const initialFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

// Board representation: 8x8 array with piece codes: 'P','p','K','k', etc or null
function fenToBoard(fen){
  const [placement, turn, castling, ep] = fen.split(' ');
  const rows = placement.split('/');
  let board = Array.from({length:8},()=>Array(8).fill(null));
  for(let r=0;r<8;r++){
    let file=0;
    for(const ch of rows[r]){
      if(/[1-8]/.test(ch)){ file+=parseInt(ch); }
      else { board[r][file]=ch; file++; }
    }
  }
  return {board, turn: turn==='w'?'w':'b', castling: castling==='-'? '': castling, ep: ep==='-'?null:ep };
}
function boardToFEN(state){
  let out='';
  for(let r=0;r<8;r++){
    let empty=0;
    for(let f=0;f<8;f++){
      const p = state.board[r][f];
      if(!p) empty++; else { if(empty){ out+=empty; empty=0;} out+=p; }
    }
    if(empty) out+=empty;
    if(r<7) out+='/';
  }
  const turn = state.turn;
  const castling = state.castling || '-';
  const ep = state.ep || '-';
  return `${out} ${turn} ${castling} ${ep} 0 1`;
}

function algebraic(r,f){ return 'abcdefgh'[f] + (8-r); }
function fromAlg(s){ const f='abcdefgh'.indexOf(s[0]); const r=8-parseInt(s[1]); return [r,f]; }

// Initialize
let gameState = fenToBoard(initialFEN);
let moveHistory = [];
let selected = null; // {r,f}
let legalOnly=true;
let lastMoveHighlight = [];

// Castling rights in state.castling like "KQkq"

// --- Rendering
const boardEl = document.getElementById('board');
const turnLabel = document.getElementById('turnLabel');
const statusLabel = document.getElementById('statusLabel');
const movesList = document.getElementById('movesList');

function renderBoard(){
  boardEl.innerHTML='';
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      const sq=document.createElement('div');
      sq.className='square '+(((r+f)%2) ? 'dark':'light');
      sq.dataset.r=r; sq.dataset.f=f; sq.id=`sq-${r}-${f}`;
      // coord labels
      if((r===7 && document.getElementById('showCoords').checked) || (f===0 && document.getElementById('showCoords').checked)){
        const small=document.createElement('div');
        small.style.fontSize='11px'; small.style.position='absolute'; small.style.left='6px'; small.style.top='6px'; small.style.color='rgba(0,0,0,0.2)';
        small.innerText = algebraic(r,f);
        sq.appendChild(small);
      }
      const p = gameState.board[r][f];
      if(p){
        const span=document.createElement('div'); span.className='piece'; span.draggable=true; span.style.fontSize='34px';
        span.innerHTML = pieceToUnicode(p);
        span.dataset.p=p; span.dataset.r=r; span.dataset.f=f;
        span.addEventListener('dragstart',e=>dragStart(e,r,f));
        sq.appendChild(span);
      }
      sq.addEventListener('click',()=>onSquareClick(r,f));
      sq.addEventListener('dragover',e=>e.preventDefault());
      sq.addEventListener('drop',e=>onDrop(e,r,f));
      boardEl.appendChild(sq);
    }
  }
  // highlight last move
  lastMoveHighlight.forEach(a=>{ const el=document.getElementById(`sq-${a[0]}-${a[1]}`); if(el) el.classList.add('last-move'); });
  // if selected, show legal moves
  if(selected){
    const sqSel = document.getElementById(`sq-${selected.r}-${selected.f}`);
    if(sqSel) sqSel.classList.add('highlight');
    const moves = generateLegalMovesForSquare(selected.r, selected.f);
    for(const mv of moves){ const e=document.getElementById(`sq-${mv.to[0]}-${mv.to[1]}`); if(e) e.classList.add('highlight'); }
  }
  turnLabel.innerText = gameState.turn === 'w' ? 'White to move' : 'Black to move';
}

function pieceToUnicode(p){
  const map = {P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔', p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚'};
  return map[p]||p;
}

// --- Drag/drop handlers
function dragStart(e,r,f){ selected={r,f}; setStatus('Piece selected'); renderBoard(); }
function onDrop(e,r,f){ if(!selected) return; tryMakeMove(selected.r, selected.f, r, f); selected=null; renderBoard(); }
function onSquareClick(r,f){ const p = gameState.board[r][f]; if(selected && selected.r===r && selected.f===f){ selected=null; renderBoard(); return; }
  if(selected){ tryMakeMove(selected.r, selected.f, r, f); selected=null; renderBoard(); return; }
  if(p && ((p===p.toUpperCase() && gameState.turn==='w') || (p===p.toLowerCase() && gameState.turn==='b'))){ selected={r,f}; setStatus('Selected '+p); renderBoard(); }
}

// --- Move generation (pseudo-legal then filter by king safety)
function generateLegalMovesForSquare(r,f){
  const p = gameState.board[r][f]; if(!p) return [];
  const color = (p===p.toUpperCase()) ? 'w':'b'; if(color!==gameState.turn) return [];
  let moves = generatePseudoMoves(r,f,p);
  // filter illegal moves: those leaving king in check
  const legal = moves.filter(mv=>{
    const snapshot = saveStateForTest();
    makeMoveInternal(mv);
    const ok = !isKingInCheck(color);
    restoreStateFromTest(snapshot);
    return ok;
  });
  return legal;
}

function generateAllLegalMoves(color){
  let out=[];
  for(let r=0;r<8;r++) for(let f=0;f<8;f++){
    const p = gameState.board[r][f]; if(!p) continue;
    const c = p===p.toUpperCase()?'w':'b'; if(c!==color) continue;
    const moves = generateLegalMovesForSquare(r,f);
    for(const mv of moves) out.push(mv);
  }
  return out;
}

function generatePseudoMoves(r,f,p){
  const moves=[];
  const color = p===p.toUpperCase() ? 'w':'b';
  const dir = (color==='w') ? -1:1;
  const opp = color==='w'?'b':'w';
  const isUpper = p===p.toUpperCase();
  const lowerP = p.toLowerCase();
  if(lowerP==='p'){
    // forward
    const r1 = r+dir;
    if(inBounds(r1,f) && !gameState.board[r1][f]){
      moves.push({from:[r,f],to:[r1,f],piece:p,type:'move'});
      // double
      const startRow = color==='w'?6:1;
      if(r===startRow){ const r2=r+dir*2; if(!gameState.board[r2][f]) moves.push({from:[r,f],to:[r2,f],piece:p,type:'double'}); }
    }
    // captures
    for(const df of [-1,1]){
      const rf = r+dir, ff=f+df;
      if(inBounds(rf,ff)){
        const target = gameState.board[rf][ff];
        if(target && ((target===target.toUpperCase() && color==='b') || (target===target.toLowerCase() && color==='w'))){
          moves.push({from:[r,f],to:[rf,ff],piece:p,type:'capture'});
        }
      }
    }
    // en passant
    if(gameState.ep){
      const ep = fromAlg(gameState.ep);
      if(Math.abs(ep[1]-f)===1 && ep[0]===r+dir){ moves.push({from:[r,f],to:[ep[0],ep[1]],piece:p,type:'enpassant'}); }
    }
  }
  else if(lowerP==='n'){
    const dirs=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
    for(const d of dirs){ const rr=r+d[0], ff=f+d[1]; if(inBounds(rr,ff) && !isOwn(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:isEnemy(rr,ff,color)?'capture':'move'}); }
  }
  else if(lowerP==='b' || lowerP==='r' || lowerP==='q'){
    const vectors = [];
    if(lowerP==='b' || lowerP==='q') vectors.push(...[[1,1],[1,-1],[-1,1],[-1,-1]]);
    if(lowerP==='r' || lowerP==='q') vectors.push(...[[1,0],[-1,0],[0,1],[0,-1]]);
    for(const v of vectors){
      let rr=r+v[0], ff=f+v[1];
      while(inBounds(rr,ff)){
        if(!gameState.board[rr][ff]){ moves.push({from:[r,f],to:[rr,ff],piece:p,type:'move'}); }
        else { if(isEnemy(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:'capture'}); break; }
        rr+=v[0]; ff+=v[1];
      }
    }
  }
  else if(lowerP==='k'){
    for(let dr=-1;dr<=1;dr++) for(let df=-1;df<=1;df++){ if(dr===0 && df===0) continue; const rr=r+dr, ff=f+df; if(inBounds(rr,ff) && !isOwn(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:isEnemy(rr,ff,color)?'capture':'move'}); }
    // castling
    if(color==='w'){
      if(gameState.castling && gameState.castling.includes('K')){
        // check path f+1,f+2 empty and not attacked and king not in check
        if(!gameState.board[7][5] && !gameState.board[7][6]) moves.push({from:[7,4],to:[7,6],piece:p,type:'castleK'});
      }
      if(gameState.castling && gameState.castling.includes('Q')){
        if(!gameState.board[7][1] && !gameState.board[7][2] && !gameState.board[7][3]) moves.push({from:[7,4],to:[7,2],piece:p,type:'castleQ'});
      }
    } else {
      if(gameState.castling && gameState.castling.includes('k')){
        if(!gameState.board[0][5] && !gameState.board[0][6]) moves.push({from:[0,4],to:[0,6],piece:p,type:'castleK'});
      }
      if(gameState.castling && gameState.castling.includes('q')){
        if(!gameState.board[0][1] && !gameState.board[0][2] && !gameState.board[0][3]) moves.push({from:[0,4],to:[0,2],piece:p,type:'castleQ'});
      }
    }
  }
  return moves;
}

function inBounds(r,f){ return r>=0 && r<8 && f>=0 && f<8; }
function isOwn(r,f,color){ const t=gameState.board[r][f]; if(!t) return false; return (t===t.toUpperCase() && color==='w') || (t===t.toLowerCase() && color==='b'); }
function isEnemy(r,f,color){ const t=gameState.board[r][f]; if(!t) return false; return (t===t.toUpperCase() && color==='b') || (t===t.toLowerCase() && color==='w'); }

// Simulate move enforcement
function tryMakeMove(r1,f1,r2,f2){
  const p = gameState.board[r1][f1]; if(!p) return false;
  const moves = generateLegalMovesForSquare(r1,f1);
  const mv = moves.find(m=>m.to[0]===r2 && m.to[1]===f2);
  if(!mv){ setStatus('Illegal move'); return false; }
  // promote? If pawn reaches last rank
  if(mv.piece.toLowerCase()==='p' && (r2===0 || r2===7)){
    // open promotion modal
    showPromotionChooser(mv, chosen=>{ makeMove(mv, chosen); });
  } else {
    makeMove(mv);
  }
  return true;
}

function makeMove(mv, promotionChoice){
  // push history
  const hist = {state:deepClone(gameState), mv};
  moveHistory.push(hist);
  makeMoveInternal(mv, promotionChoice);
  // update last move highlight
  lastMoveHighlight = [mv.from, mv.to];
  renderMoves();
  renderBoard();
}

function makeMoveInternal(mv, promotionChoice){
  const [r1,f1]=mv.from; const [r2,f2]=mv.to; const p = gameState.board[r1][f1];
  // handle special
  if(mv.type==='enpassant'){
    // capturing pawn behind
    const capR = r1; const capF = f2; // pawn captured
    gameState.board[capR][capF]=null;
  }
  if(mv.type==='castleK'){
    // king moves two, rook moves
    if(gameState.turn==='w'){
      gameState.board[7][6]=gameState.board[7][4]; gameState.board[7][4]=null;
      gameState.board[7][5]=gameState.board[7][7]; gameState.board[7][7]=null;
    } else {
      gameState.board[0][6]=gameState.board[0][4]; gameState.board[0][4]=null;
      gameState.board[0][5]=gameState.board[0][7]; gameState.board[0][7]=null;
    }
    // clear castling rights for that side
    if(gameState.turn==='w') gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
    gameState.ep=null; gameState.turn = gameState.turn==='w'?'b':'w'; return;
  }
  if(mv.type==='castleQ'){
    if(gameState.turn==='w'){
      gameState.board[7][2]=gameState.board[7][4]; gameState.board[7][4]=null;
      gameState.board[7][3]=gameState.board[7][0]; gameState.board[7][0]=null;
    } else {
      gameState.board[0][2]=gameState.board[0][4]; gameState.board[0][4]=null;
      gameState.board[0][3]=gameState.board[0][0]; gameState.board[0][0]=null;
    }
    if(gameState.turn==='w') gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
    gameState.ep=null; gameState.turn = gameState.turn==='w'?'b':'w'; return;
  }
  // normal move or capture
  gameState.board[r2][f2] = gameState.board[r1][f1]; gameState.board[r1][f1]=null;
  // pawn double -> set ep
  if(mv.type==='double'){
    const epR = (r1 + r2)/2; gameState.ep = algebraic(epR,f1);
  } else {
    gameState.ep = null;
  }
  // promotion
  if(p.toLowerCase()==='p' && (r2===0 || r2===7)){
    const make = promotionChoice||'q';
    const color = p===p.toUpperCase()?'w':'b';
    const pieceChar = color==='w'?make.toUpperCase():make.toLowerCase();
    gameState.board[r2][f2] = pieceChar;
  }
  // clear castling rights if rook or king moved or captured
  if(p.toLowerCase()==='k'){
    if(p===p.toUpperCase()) gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
  }
  if(p.toLowerCase()==='r'){
    if(r1===7 && f1===0) gameState.castling = gameState.castling.replace('Q','');
    if(r1===7 && f1===7) gameState.castling = gameState.castling.replace('K','');
    if(r1===0 && f1===0) gameState.castling = gameState.castling.replace('q','');
    if(r1===0 && f1===7) gameState.castling = gameState.castling.replace('k','');
  }
  // if captured a rook, update rights
  if(mv.type==='capture'){
    if(r2===7 && f2===0) gameState.castling = gameState.castling.replace('Q','');
    if(r2===7 && f2===7) gameState.castling = gameState.castling.replace('K','');
    if(r2===0 && f2===0) gameState.castling = gameState.castling.replace('q','');
    if(r2===0 && f2===7) gameState.castling = gameState.castling.replace('k','');
  }
  // switch turn
  gameState.turn = gameState.turn==='w'?'b':'w';
}

function saveStateForTest(){ return deepClone(gameState); }
function restoreStateFromTest(s){ gameState = s; }

function isKingInCheck(color){
  // find king
  let kr=-1,kf=-1; for(let r=0;r<8;r++) for(let f=0;f<8;f++){ const p=gameState.board[r][f]; if(p && ((p==='K' && color==='w') || (p==='k' && color==='b'))){ kr=r;kf=f; } }
  if(kr===-1) return true; // no king
  // find any enemy piece attacking (kr,kf)
  const enemy = color==='w'?'b':'w';
  // pawn attacks
  const pd = color==='w'?-1:1;
  for(const df of [-1,1]){
    const rr=kr+pd, ff=kf+df; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && ((t==='p' && enemy==='b') || (t==='P' && enemy==='w'))) return true; }
  }
  // knight
  const ndirs=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  for(const d of ndirs){ const rr=kr+d[0], ff=kf+d[1]; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && (t.toLowerCase()==='n') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; } }
  // sliders
  const rays = {rook:[[1,0],[-1,0],[0,1],[0,-1]], bishop:[[1,1],[1,-1],[-1,1],[-1,-1]] };
  for(const v of rays.rook){ let rr=kr+v[0], ff=kf+v[1]; while(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t){ if((t.toLowerCase()==='r' || t.toLowerCase()==='q') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; else break; } rr+=v[0]; ff+=v[1]; } }
  for(const v of rays.bishop){ let rr=kr+v[0], ff=kf+v[1]; while(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t){ if((t.toLowerCase()==='b' || t.toLowerCase()==='q') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; else break; } rr+=v[0]; ff+=v[1]; } }
  // king adjacent
  for(let dr=-1;dr<=1;dr++) for(let df=-1;df<=1;df++){ if(dr===0&&df===0) continue; const rr=kr+dr, ff=kf+df; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && t.toLowerCase()==='k' && ((t===t.toUpperCase())=== (enemy==='w'))) return true; } }
  return false;
}

// --- UI helpers
function setStatus(s){ statusLabel.innerText = s; }

function renderMoves(){ movesList.innerHTML=''; for(let i=0;i<moveHistory.length;i++){ const mv = moveHistory[i].mv; const from=algebraic(mv.from[0],mv.from[1]); const to=algebraic(mv.to[0],mv.to[1]); const el=document.createElement('div'); el.innerText = (i+1)+'. '+from+'-'+to+' '+(mv.type||''); movesList.appendChild(el); } }

// Undo/Reset
document.getElementById('undoBtn').addEventListener('click',()=>{ if(moveHistory.length===0) return; const last = moveHistory.pop(); gameState = last.state; lastMoveHighlight = []; renderMoves(); renderBoard(); });
document.getElementById('resetBtn').addEventListener('click',()=>{ gameState = fenToBoard(initialFEN); moveHistory=[]; lastMoveHighlight=[]; renderMoves(); renderBoard(); });

// Options
document.getElementById('legalOnly').addEventListener('change',e=>{ legalOnly = e.target.checked; });
document.getElementById('showCoords').addEventListener('change',e=>{ renderBoard(); });

// Promotion modal
let promotionCallback=null; function showPromotionChooser(mv, cb){ promotionCallback = cb; const pb = document.getElementById('promoButtons'); pb.innerHTML=''; ['q','r','b','n'].forEach(p=>{ const b=document.createElement('button'); b.className='btn'; b.innerText = p.toUpperCase(); b.addEventListener('click',()=>{ hidePromotion(); cb(p); }); pb.appendChild(b); }); document.getElementById('promotionModal').style.display='block'; }
function hidePromotion(){ document.getElementById('promotionModal').style.display='none'; promotionCallback=null; }
document.getElementById('promoCancel').addEventListener('click',()=>{ hidePromotion(); });

// Setup initial rights
if(!gameState.castling) gameState.castling='KQkq';

/* --- Saving snapshots & node graph (updated) --- */
const saveCanvas = document.getElementById('saveCanvas');
const connectionsSVG = document.getElementById('connections');

// load or migrate saves
let saves = loadSaves(); let selectedNodeId = null;
let baseNodeId = null; // selected "base" for future saves

renderSaves();

// Save current snapshot as a new node (child of baseNodeId if set)
function saveCurrentSnapshot(){
  const fen = boardToFEN(gameState);
  const id = 'n'+Date.now();
  const created = Date.now();
  // default location layout
  const count = Object.keys(saves).length;
  const node = {
    id,
    fen,
    x:20 + (count%6)*120,
    y:20 + Math.floor(count/6)*80,
    links:[],
    parent: baseNodeId || null,
    created
  };
  saves[id]=node;
  // if a base is set, auto-link it (append -> keeps chronological order)
  if(baseNodeId && saves[baseNodeId]){
    // ensure no duplicate
    if(!saves[baseNodeId].links.includes(id)) saves[baseNodeId].links.push(id);
  }
  persistSaves();
  renderSaves();
}
document.getElementById('saveBtn').addEventListener('click',saveCurrentSnapshot);

// clear all saves
document.getElementById('clearSaves').addEventListener('click',()=>{
  if(confirm('Clear all saves?')){ saves={}; persistSaves(); selectedNodeId=null; baseNodeId=null; renderSaves(); }
});

// Select as base / clear base
document.getElementById('selectAsBaseBtn').addEventListener('click',()=>{
  if(!selectedNodeId){ alert('Select a node first by clicking it.'); return; }
  baseNodeId = selectedNodeId;
  renderSaves();
});
document.getElementById('clearBaseBtn').addEventListener('click',()=>{
  baseNodeId = null; renderSaves();
});

// Delete selected node and its descendants
document.getElementById('deleteNodeBtn').addEventListener('click',()=>{
  if(!selectedNodeId) return alert('Select a node first by clicking it');
  if(!confirm('Delete this node and all its descendants?')) return;
  deleteNodeAndDescendants(selectedNodeId);
  selectedNodeId=null; if(baseNodeId && !saves[baseNodeId]) baseNodeId=null;
  persistSaves(); renderSaves();
});

function deleteNodeAndDescendants(id){
  if(!saves[id]) return;
  // recursively delete children
  for(const childId of (saves[id].links||[])){
    if(saves[childId]) deleteNodeAndDescendants(childId);
  }
  // remove references from parent (if any)
  const parent = saves[id].parent;
  if(parent && saves[parent]){
    saves[parent].links = (saves[parent].links||[]).filter(x=>x!==id);
  }
  // remove any links pointing to this node from other nodes (guard)
  for(const key in saves){
    if(saves[key].links && saves[key].links.includes(id)){
      saves[key].links = saves[key].links.filter(x=>x!==id);
    }
  }
  delete saves[id];
}

// storage
function persistSaves(){ localStorage.setItem('chess_saves', JSON.stringify(saves)); }
function loadSaves(){
  try{ const raw = JSON.parse(localStorage.getItem('chess_saves') || '{}'); return raw || {}; }catch(e){ return {}; }
}

// render nodes as mini-boards with no text
function renderSaves(){
  saveCanvas.innerHTML=''; saveCanvas.appendChild(connectionsSVG);
  // node elements
  for(const id in saves){
    const node = saves[id];
    const el = document.createElement('div');
    el.className='node';
    el.style.left = node.x + 'px';
    el.style.top = node.y + 'px';
    el.id = 'node-'+id;

    // mini-board element
    const mini = document.createElement('div'); mini.className='mini-board';
    // create mini squares 8x8
    // We need to render from the node.fen -> board
    const nodeState = fenToBoard(node.fen);
    for(let r=0;r<8;r++){
      for(let f=0;f<8;f++){
        const sq = document.createElement('div');
        const isDark = ((r+f)%2)!==0;
        sq.className = 'mini-square ' + (isDark ? 'dark' : 'light');
        const p = nodeState.board[r][f];
        if(p) sq.innerText = pieceToUnicode(p);
        mini.appendChild(sq);
      }
    }
    el.appendChild(mini);

    // show base selection outline if matches
    if(baseNodeId === id) el.classList.add('base-selected'); else el.classList.remove('base-selected');

    // events: drag, click
    el.addEventListener('mousedown', startDragNode(id));
    el.addEventListener('click', e=>{ e.stopPropagation(); selectNode(id); });

    saveCanvas.appendChild(el);
  }
  drawConnections();
}

// selecting node: loads snapshot into main board and marks selected node visually
function selectNode(id){
  selectedNodeId = id;
  // load snapshot into main board
  const fen = saves[id].fen;
  gameState = fenToBoard(fen);
  moveHistory = []; lastMoveHighlight = [];
  renderBoard();
  renderSaves();
}

// dragging (same as before)
let dragInfo = null;
function startDragNode(id){
  return function(e){
    e.preventDefault();
    dragInfo = { id, ox: e.clientX, oy: e.clientY, startX: saves[id].x, startY: saves[id].y };
    document.addEventListener('mousemove', onDragNode);
    document.addEventListener('mouseup', stopDragNode);
  }
}
function onDragNode(e){
  if(!dragInfo) return;
  const dx = e.clientX - dragInfo.ox, dy = e.clientY - dragInfo.oy;
  const id = dragInfo.id;
  saves[id].x = dragInfo.startX + dx;
  saves[id].y = dragInfo.startY + dy;
  persistSaves();
  renderSaves();
}
function stopDragNode(e){
  dragInfo = null;
  document.removeEventListener('mousemove', onDragNode);
  document.removeEventListener('mouseup', stopDragNode);
}

// clicking empty area deselects & clears visual selection
saveCanvas.addEventListener('click', ()=>{ selectedNodeId = null; renderSaves(); });

// Draw SVG curved connections (keeps chronological order based on node.created)
function drawConnections(){
  connectionsSVG.innerHTML='';
  // compute rect offset of canvas to handle absolute coords
  const rect = saveCanvas.getBoundingClientRect();
  for(const id in saves){
    const node = saves[id];
    // ensure links are sorted by created time of target (defensive)
    const links = (node.links || []).filter(t=>saves[t]).sort((a,b)=> (saves[a].created||0) - (saves[b].created||0));
    for(const t of links){
      const target = saves[t];
      if(!target) continue;
      const x1 = node.x + 100, y1 = node.y + 42; // right center of node
      const x2 = target.x + 10, y2 = target.y + 42; // left center of target
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', `M ${x1} ${y1} C ${x1+40} ${y1} ${x2-40} ${y2} ${x2} ${y2}`);
      path.setAttribute('stroke', '#2b6cb0');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      connectionsSVG.appendChild(path);
    }
  }
}

// if no saves, keep empty (optional sample)
if(Object.keys(saves).length === 0){
  // no-op (keeps empty)
}
// --- Helpers for testing
function isAttacked(squareR, squareF, byColor){ // temporary: used to check castling path safety
  const snapshot = saveStateForTest(); const saveTurn = gameState.turn; gameState.turn = byColor; const moves = generateAllLegalMoves(byColor); gameState.turn = saveTurn; restoreStateFromTest(snapshot);
  return moves.some(m=>m.to[0]===squareR && m.to[1]===squareF);
}

// Re-render initially
renderBoard();

</script>
</body>
</html>
