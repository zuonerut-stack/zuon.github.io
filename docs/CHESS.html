<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess Study v4</title>
<style>
:root{
  --board-size:min(50vh,50vw);
  --square-size: calc(var(--board-size) / 8);
}
body{font-family: Inter, system-ui, Arial; background:#f2efe9; margin:20px; color:#222}
.app{display:flex;gap:24px;align-items:flex-start}
.board-wrap{background:linear-gradient(180deg,#e6d9c3,#d7c4a6);padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.12)}
.board{aspect-ratio: 1 / 1;
  width: var(--board-size); display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows: repeat(8, 1fr);border-radius:6px;overflow:hidden;position:relative}
.square{width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:30px;user-select:none}
.square.light{background:linear-gradient(180deg,#fdf5e9,#f7e9d1)}
.square.dark{background:linear-gradient(180deg,#c49663,#8f5b33)}
.square.highlight{outline:4px solid rgba(255,255,0,0.45);box-sizing:border-box}
.square.last-move{box-shadow:inset 0 0 40px rgba(255,255,255,0.06)}
.coords{position:absolute;left:6px;top:6px;font-size:12px;color:rgba(0,0,0,0.45)}
.controls{width:60%}
.controls .panel{background:white;padding:12px;border-radius:10px;box-shadow:0 6px 14px rgba(0,0,0,0.06);margin-bottom:12px}
.btn{display:inline-block;padding:8px 12px;border-radius:8px;background:#2b6cb0;color:white;text-decoration:none;cursor:pointer}
.btn.secondary{background:#718096}
.piece {
  font-size: calc(var(--board-size)/10);
  line-height: 1;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:grab;
}
.thumb {
  width: 100%;
  height: 100%;
  object-fit: cover;  /* or contain */
  border-radius: 5px;user-drag:none;
}
.row{display:flex;gap:8px;align-items:center}
.meta{font-size:13px;color:#444}
.moves-list{max-height:140px;overflow:auto;padding:8px;border-radius:4px;background:#fbfbfb}
.board-options{display:flex;gap:8px;margin-bottom:8px}
.save-stage{background:#ffffff;padding:10px;border-radius:10px;min-height:220px}
.save-item{background:#f7f7f8;padding:8px;border-radius:8px;margin:6px;display:inline-block;cursor:grab}
.save-toolbar{display:flex;gap:8px;flex-wrap:wrap}
.save-canvas{overflow=hidden;position:relative;height:90vh;border-radius:8px;background:linear-gradient(180deg,#fffafa,#f6fcff);overflow:auto}
.node{pointer-events:auto;position:absolute;padding:0;background:none;border-radius:5px;border:2px solid #444;cursor:grab;width:150px;height:150px;align-items:center;display:flex;justify-content:center;overflow:hidden;}
.node .title{font-weight:600;font-size:13px}
.node small{display:block;color:#666;margin-top:4px}
#transformWrapper {
    pointer-events: none;
}

svg.connections{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;}
.notice{font-size:13px;color:#666}
.promotion-modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:white;padding:14px;border-radius:10px;box-shadow:0 20px 50px rgba(0,0,0,0.2)}
.promotion-modal button{margin:6px}
.footer{font-size:12px;color:#666;margin-top:8px}
.base-indicator{font-size:12px;color:#2b6cb0;margin-left:8px}
</style>
</head>
<body>
<div class="app">
  <div class="board-wrap">
    <div class="coords">a1 - h8 (drag pieces or click)</div>
    <div id="board" class="board"></div>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:space-between;align-items:center">
      <div class="meta"><span id="turnLabel">White to move</span> • <span id="statusLabel">Ready</span></div>
      <div>
        <button class="btn" id="undoBtn">Undo</button>
        <button class="btn secondary" id="resetBtn">Reset</button>
      </div>
    </div>
  </div>
  <div class="controls">
	
    <div id="movesList" class="moves-list"></div>
    <div class="panel save-stage">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">Save & Lines (Snapshots)</div>
        <div class="save-toolbar">
          <button class="btn" id="saveBtn">Save Snapshot</button>
          <button class="btn secondary" id="clearSaves">Clear Saves</button>
        </div>
      </div>
      <div style="margin-top:8px" class="save-canvas" id="saveCanvas">
        <svg class="connections" id="connections"></svg>
      </div>
      <div style="margin-top:8px">
        <div class="notice">Click a node to load that snapshot. Drag nodes to arrange. Use 'Set Base' to define which node becomes the ancestor for newly created nodes (branching).</div>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <input id="nodeName" placeholder="name for selected node" style="flex:1;padding:8px;border-radius:8px;border:1px solid #ddd" />
        <button class="btn" id="renameNode">Rename</button>
        <button class="btn secondary" id="setBaseBtn">Set Base</button>
        <button class="btn secondary" id="clearBaseBtn">Clear Base</button>
        <span class="base-indicator" id="baseIndicator" style="display:none">Base: <span id="baseName"></span></span>
      </div>
    </div>

  </div>
</div>

<div id="promotionModal" class="promotion-modal" style="display:none">
  <div style="font-weight:700;margin-bottom:8px">Choose promotion piece</div>
  <div id="promoButtons"></div>
  <div style="text-align:right;margin-top:8px"><button class="btn secondary" id="promoCancel">Cancel</button></div>
</div>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
/*
  Fixed Save & Nodes:
  - Snapshot name uses the last move (option A)
  - Set Base / Clear Base controls
  - Automatic parent/child linking (parent stored in node.parent; links array kept for drawing)
  - Draw connections parent -> child automatically
  - Restores previous snapshot functionality and avoids the bug that broke saves
*/

// --- Utilities
const PIECES = { p:'pawn', r:'rook', n:'knight', b:'bishop', q:'queen', k:'king' };
const initialFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

let dragInfo=null;

function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

let cameraScale = 1.0;
let cameraX = 0;
let cameraY = 0;

const MIN_ZOOM = 0.2;
const MAX_ZOOM = 3.0;

function applyCameraTransform() {
    const wrapper = document.getElementById("transformWrapper");
    if (!wrapper) return;
    wrapper.style.transform = `translate(${cameraX}px, ${cameraY}px) scale(${cameraScale})`;
    drawConnections(document.getElementById("connections"));
}

async function renderBoardToCanvas() {
  const oldSelected = selected;
  selected = null;
  const oldLast = lastMoveHighlight;
  lastMoveHighlight = [];

  renderBoard();

  const boardElement = document.getElementById("board");
  const canvasResult = await html2canvas(document.getElementById("board"), {
    backgroundColor: null
});
  selected = oldSelected;
  lastMoveHighlight = oldLast;

  renderBoard();

  return canvasResult;
}

function fenToBoard(fen){
  const [placement, turn, castling, ep] = fen.split(' ');
  const rows = placement.split('/');
  let board = Array.from({length:8},()=>Array(8).fill(null));
  for(let r=0;r<8;r++){
    let file=0;
    for(const ch of rows[r]){
      if(/[1-8]/.test(ch)){ file+=parseInt(ch); }
      else { board[r][file]=ch; file++; }
    }
  }
  return {board, turn: turn==='w'?'w':'b', castling: castling==='-'? '': castling, ep: ep==='-'?null:ep };
}
function boardToFEN(state){
  let out='';
  for(let r=0;r<8;r++){
    let empty=0;
    for(let f=0;f<8;f++){
      const p = state.board[r][f];
      if(!p) empty++; else { if(empty){ out+=empty; empty=0;} out+=p; }
    }
    if(empty) out+=empty;
    if(r<7) out+='/';
  }
  const turn = state.turn;
  const castling = state.castling || '-';
  const ep = state.ep || '-';
  return `${out} ${turn} ${castling} ${ep} 0 1`;
}

function algebraic(r,f){ return 'abcdefgh'[f] + (8-r); }
function fromAlg(s){ const f='abcdefgh'.indexOf(s[0]); const r=8-parseInt(s[1]); return [r,f]; }

// --- Game state
let gameState = fenToBoard(initialFEN);
let moveHistory = [];
let selected = null; // {r,f}
let legalOnly=true;
let lastMoveHighlight = [];

if(!gameState.castling) gameState.castling='KQkq';

// --- Rendering

function renderBoard(){
  boardEl.innerHTML='';
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      const sq=document.createElement('div');
      sq.className='square '+(((r+f)%2) ? 'dark':'light');
      sq.dataset.r=r; sq.dataset.f=f; sq.id=`sq-${r}-${f}`;
      
      const p = gameState.board[r][f];
      if(p){
        const span=document.createElement('div'); span.className='piece'; span.draggable=true; 
        span.innerHTML = pieceToUnicode(p);
        span.dataset.p=p; span.dataset.r=r; span.dataset.f=f;
        span.addEventListener('dragstart',e=>dragStart(e,r,f));
        sq.appendChild(span);
      }
      sq.addEventListener('click',()=>onSquareClick(r,f));
      sq.addEventListener('dragover',e=>e.preventDefault());
      sq.addEventListener('drop',e=>onDrop(e,r,f));
      boardEl.appendChild(sq);
    }
  }
  // highlight last move
  lastMoveHighlight.forEach(a=>{ const el=document.getElementById(`sq-${a[0]}-${a[1]}`); if(el) el.classList.add('last-move'); });
  if(selected){
    const sqSel = document.getElementById(`sq-${selected.r}-${selected.f}`);
    if(sqSel) sqSel.classList.add('highlight');
    const moves = generateLegalMovesForSquare(selected.r, selected.f);
    for(const mv of moves){ const e=document.getElementById(`sq-${mv.to[0]}-${mv.to[1]}`); if(e) e.classList.add('highlight'); }
  }
  turnLabel.innerText = gameState.turn === 'w' ? 'White to move' : 'Black to move';
}

function pieceToUnicode(p){
  const map = {P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔', p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚'};
  return map[p]||p;
}

// --- Drag/drop handlers
function dragStart(e,r,f){ selected={r,f}; setStatus('Piece selected'); renderBoard(); }
function onDrop(e,r,f){ if(!selected) return; tryMakeMove(selected.r, selected.f, r, f); selected=null; renderBoard(); }
function onSquareClick(r,f){ const p = gameState.board[r][f]; if(selected && selected.r===r && selected.f===f){ selected=null; renderBoard(); return; }
  if(selected){ tryMakeMove(selected.r, selected.f, r, f); selected=null; renderBoard(); return; }
  if(p && ((p===p.toUpperCase() && gameState.turn==='w') || (p===p.toLowerCase() && gameState.turn==='b'))){ selected={r,f}; setStatus('Selected '+p); renderBoard(); }
}

// --- Move generation and legality
function generateLegalMovesForSquare(r,f){
  const p = gameState.board[r][f]; if(!p) return [];
  const color = (p===p.toUpperCase()) ? 'w':'b'; if(color!==gameState.turn) return [];
  let moves = generatePseudoMoves(r,f,p);
  const legal = moves.filter(mv=>{
    const snapshot = saveStateForTest();
    makeMoveInternal(mv);
    const ok = !isKingInCheck(color);
    restoreStateFromTest(snapshot);
    return ok;
  });
  return legal;
}

function generateAllLegalMoves(color){
  let out=[];
  for(let r=0;r<8;r++) for(let f=0;f<8;f++){
    const p = gameState.board[r][f]; if(!p) continue;
    const c = p===p.toUpperCase()?'w':'b'; if(c!==color) continue;
    const moves = generateLegalMovesForSquare(r,f);
    for(const mv of moves) out.push(mv);
  }
  return out;
}

function generatePseudoMoves(r,f,p){
  const moves=[];
  const color = p===p.toUpperCase() ? 'w':'b';
  const dir = (color==='w') ? -1:1;
  const opp = color==='w'?'b':'w';
  const isUpper = p===p.toUpperCase();
  const lowerP = p.toLowerCase();
  if(lowerP==='p'){
    const r1 = r+dir;
    if(inBounds(r1,f) && !gameState.board[r1][f]){
      moves.push({from:[r,f],to:[r1,f],piece:p,type:'move'});
      const startRow = color==='w'?6:1;
      if(r===startRow){ const r2=r+dir*2; if(!gameState.board[r2][f]) moves.push({from:[r,f],to:[r2,f],piece:p,type:'double'}); }
    }
    for(const df of [-1,1]){
      const rf = r+dir, ff=f+df;
      if(inBounds(rf,ff)){
        const target = gameState.board[rf][ff];
        if(target && ((target===target.toUpperCase() && color==='b') || (target===target.toLowerCase() && color==='w'))){
          moves.push({from:[r,f],to:[rf,ff],piece:p,type:'capture'});
        }
      }
    }
    if(gameState.ep){
      const ep = fromAlg(gameState.ep);
      if(Math.abs(ep[1]-f)===1 && ep[0]===r+dir){ moves.push({from:[r,f],to:[ep[0],ep[1]],piece:p,type:'enpassant'}); }
    }
  }
  else if(lowerP==='n'){
    const dirs=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
    for(const d of dirs){ const rr=r+d[0], ff=f+d[1]; if(inBounds(rr,ff) && !isOwn(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:isEnemy(rr,ff,color)?'capture':'move'}); }
  }
  else if(lowerP==='b' || lowerP==='r' || lowerP==='q'){
    const vectors = [];
    if(lowerP==='b' || lowerP==='q') vectors.push(...[[1,1],[1,-1],[-1,1],[-1,-1]]);
    if(lowerP==='r' || lowerP==='q') vectors.push(...[[1,0],[-1,0],[0,1],[0,-1]]);
    for(const v of vectors){
      let rr=r+v[0], ff=f+v[1];
      while(inBounds(rr,ff)){
        if(!gameState.board[rr][ff]){ moves.push({from:[r,f],to:[rr,ff],piece:p,type:'move'}); }
        else { if(isEnemy(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:'capture'}); break; }
        rr+=v[0]; ff+=v[1];
      }
    }
  }
  else if(lowerP==='k'){
    for(let dr=-1;dr<=1;dr++) for(let df=-1;df<=1;df++){ if(dr===0 && df===0) continue; const rr=r+dr, ff=f+df; if(inBounds(rr,ff) && !isOwn(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:isEnemy(rr,ff,color)?'capture':'move'}); }
    if(color==='w'){
      if(gameState.castling && gameState.castling.includes('K')){
        if(!gameState.board[7][5] && !gameState.board[7][6]) moves.push({from:[7,4],to:[7,6],piece:p,type:'castleK'});
      }
      if(gameState.castling && gameState.castling.includes('Q')){
        if(!gameState.board[7][1] && !gameState.board[7][2] && !gameState.board[7][3]) moves.push({from:[7,4],to:[7,2],piece:p,type:'castleQ'});
      }
    } else {
      if(gameState.castling && gameState.castling.includes('k')){
        if(!gameState.board[0][5] && !gameState.board[0][6]) moves.push({from:[0,4],to:[0,6],piece:p,type:'castleK'});
      }
      if(gameState.castling && gameState.castling.includes('q')){
        if(!gameState.board[0][1] && !gameState.board[0][2] && !gameState.board[0][3]) moves.push({from:[0,4],to:[0,2],piece:p,type:'castleQ'});
      }
    }
  }
  return moves;
}

function inBounds(r,f){ return r>=0 && r<8 && f>=0 && f<8; }
function isOwn(r,f,color){ const t=gameState.board[r][f]; if(!t) return false; return (t===t.toUpperCase() && color==='w') || (t===t.toLowerCase() && color==='b'); }
function isEnemy(r,f,color){ const t=gameState.board[r][f]; if(!t) return false; return (t===t.toUpperCase() && color==='b') || (t===t.toLowerCase() && color==='w'); }

function tryMakeMove(r1,f1,r2,f2){
  const p = gameState.board[r1][f1]; if(!p) return false;
  const moves = generateLegalMovesForSquare(r1,f1);
  const mv = moves.find(m=>m.to[0]===r2 && m.to[1]===f2);
  if(!mv){ setStatus('Illegal move'); return false; }
  if(mv.piece.toLowerCase()==='p' && (r2===0 || r2===7)){
    showPromotionChooser(mv, chosen=>{ makeMove(mv, chosen); });
  } else {
    makeMove(mv);
  }
  return true;
}

// --- simple SAN-like move name (basic, no full disambiguation)
// used for snapshot naming (option A)
function simpleMoveNameFromMoveAndState(preState, mv, postState){
  if(!mv) return 'start';
  if(mv.type==='castleK') return 'O-O';
  if(mv.type==='castleQ') return 'O-O-O';
  const toAlg = algebraic(mv.to[0], mv.to[1]);
  const piece = mv.piece;
  const lower = piece.toLowerCase();
  const isPawn = lower==='p';
  let isCap = mv.type==='capture' || mv.type==='enpassant';
  // if not explicit, check by comparing pre/post board
  if(!isCap){
    const preTarget = preState.board[mv.to[0]][mv.to[1]];
    if(preTarget) isCap = true;
  }
  if(isPawn){
    const fromFile = 'abcdefgh'[mv.from[1]];
    if(isCap) return `${fromFile}x${toAlg}` + (mv.type==='enpassant' ? ' ep' : '') + '';
    else return `${toAlg}`;
  } else {
    const pieceLetter = piece.toUpperCase();
    return (isCap? pieceLetter + 'x' + toAlg : pieceLetter + toAlg);
  }
}

// --- makeMove and internal apply
function makeMove(mv, promotionChoice){
  const hist = {state:deepClone(gameState), mv: deepClone(mv)};
  moveHistory.push(hist);
  makeMoveInternal(mv, promotionChoice);
  lastMoveHighlight = [mv.from, mv.to];
  renderMoves();
  renderBoard();
}

function makeMoveInternal(mv, promotionChoice){
  const [r1,f1]=mv.from; const [r2,f2]=mv.to; const p = gameState.board[r1][f1];
  if(mv.type==='enpassant'){
    const capR = r1; const capF = f2;
    gameState.board[capR][capF]=null;
  }
  if(mv.type==='castleK'){
    if(gameState.turn==='w'){
      gameState.board[7][6]=gameState.board[7][4]; gameState.board[7][4]=null;
      gameState.board[7][5]=gameState.board[7][7]; gameState.board[7][7]=null;
    } else {
      gameState.board[0][6]=gameState.board[0][4]; gameState.board[0][4]=null;
      gameState.board[0][5]=gameState.board[0][7]; gameState.board[0][7]=null;
    }
    if(gameState.turn==='w') gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
    gameState.ep=null; gameState.turn = gameState.turn==='w'?'b':'w'; return;
  }
  if(mv.type==='castleQ'){
    if(gameState.turn==='w'){
      gameState.board[7][2]=gameState.board[7][4]; gameState.board[7][4]=null;
      gameState.board[7][3]=gameState.board[7][0]; gameState.board[7][0]=null;
    } else {
      gameState.board[0][2]=gameState.board[0][4]; gameState.board[0][4]=null;
      gameState.board[0][3]=gameState.board[0][0]; gameState.board[0][0]=null;
    }
    if(gameState.turn==='w') gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
    gameState.ep=null; gameState.turn = gameState.turn==='w'?'b':'w'; return;
  }
  gameState.board[r2][f2] = gameState.board[r1][f1]; gameState.board[r1][f1]=null;
  if(mv.type==='double'){
    const epR = (r1 + r2)/2; gameState.ep = algebraic(epR,f1);
  } else {
    gameState.ep = null;
  }
  if(p.toLowerCase()==='p' && (r2===0 || r2===7)){
    const make = promotionChoice||'q';
    const color = p===p.toUpperCase()?'w':'b';
    const pieceChar = color==='w'?make.toUpperCase():make.toLowerCase();
    gameState.board[r2][f2] = pieceChar;
  }
  if(p.toLowerCase()==='k'){
    if(p===p.toUpperCase()) gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
  }
  if(p.toLowerCase()==='r'){
    if(r1===7 && f1===0) gameState.castling = gameState.castling.replace('Q','');
    if(r1===7 && f1===7) gameState.castling = gameState.castling.replace('K','');
    if(r1===0 && f1===0) gameState.castling = gameState.castling.replace('q','');
    if(r1===0 && f1===7) gameState.castling = gameState.castling.replace('k','');
  }
  if(mv.type==='capture'){
    if(r2===7 && f2===0) gameState.castling = gameState.castling.replace('Q','');
    if(r2===7 && f2===7) gameState.castling = gameState.castling.replace('K','');
    if(r2===0 && f2===0) gameState.castling = gameState.castling.replace('q','');
    if(r2===0 && f2===7) gameState.castling = gameState.castling.replace('k','');
  }
  gameState.turn = gameState.turn==='w'?'b':'w';
}

function saveStateForTest(){ return deepClone(gameState); }
function restoreStateFromTest(s){ gameState = s; }

function isKingInCheck(color){
  let kr=-1,kf=-1; for(let r=0;r<8;r++) for(let f=0;f<8;f++){ const p=gameState.board[r][f]; if(p && ((p==='K' && color==='w') || (p==='k' && color==='b'))){ kr=r;kf=f; } }
  if(kr===-1) return true;
  const enemy = color==='w'?'b':'w';
  const pd = color==='w'?-1:1;
  for(const df of [-1,1]){
    const rr=kr+pd, ff=kf+df; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && ((t==='p' && enemy==='b') || (t==='P' && enemy==='w'))) return true; }
  }
  const ndirs=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  for(const d of ndirs){ const rr=kr+d[0], ff=kf+d[1]; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && (t.toLowerCase()==='n') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; } }
  const rays = {rook:[[1,0],[-1,0],[0,1],[0,-1]], bishop:[[1,1],[1,-1],[-1,1],[-1,-1]] };
  for(const v of rays.rook){ let rr=kr+v[0], ff=kf+v[1]; while(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t){ if((t.toLowerCase()==='r' || t.toLowerCase()==='q') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; else break; } rr+=v[0]; ff+=v[1]; } }
  for(const v of rays.bishop){ let rr=kr+v[0], ff=kf+v[1]; while(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t){ if((t.toLowerCase()==='b' || t.toLowerCase()==='q') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; else break; } rr+=v[0]; ff+=v[1]; } }
  for(let dr=-1;dr<=1;dr++) for(let df=-1;df<=1;df++){ if(dr===0&&df===0) continue; const rr=kr+dr, ff=kf+df; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && t.toLowerCase()==='k' && ((t===t.toUpperCase())=== (enemy==='w'))) return true; } }
  return false;
}

// --- UI helpers
function setStatus(s){ statusLabel.innerText = s; }

function renderMoves(){ movesList.innerHTML=''; for(let i=0;i<moveHistory.length;i++){ const mv = moveHistory[i].mv; const from=algebraic(mv.from[0],mv.from[1]); const to=algebraic(mv.to[0],mv.to[1]); const el=document.createElement('div'); el.innerText = (i+1)+'. '+from+'-'+to+' '+(mv.type||''); movesList.appendChild(el); } }

// --- DOM refs (declared, initialized later in init)
let boardEl, turnLabel, statusLabel, movesList;
let saveCanvas, connectionsSVG;
let saves = {}; let selectedNodeId = null;
let baseNodeId = null;
let lastLoadedNode = null; // set by Set Base button

function showPromotionChooser(mv, callback) {
  const modal = document.getElementById("promotionModal");
  const container = document.getElementById("promoButtons");
  container.innerHTML = "";

  const color = mv.piece === mv.piece.toUpperCase() ? "w" : "b";
  const options = ["q", "r", "b", "n"];

  for (const opt of options) {
    const btn = document.createElement("button");
    btn.className = "btn";
    btn.textContent = (color === "w" ? opt.toUpperCase() : opt.toLowerCase());
    btn.addEventListener("click", () => {
      hidePromotion();
      callback(opt);
    });
    container.appendChild(btn);
  }

  modal.style.display = "block";
}

function hidePromotion() {
  const modal = document.getElementById("promotionModal");
  modal.style.display = "none";
}

// init function: assign DOM refs and wire event listeners after DOM is ready
function init() {
  // assign DOM refs
  boardEl = document.getElementById('board');
  turnLabel = document.getElementById('turnLabel');
  statusLabel = document.getElementById('statusLabel');
  movesList = document.getElementById('movesList');
  saveCanvas = document.getElementById('saveCanvas');
  connectionsSVG = document.getElementById('connections');

  // defensive checks
  if(!boardEl) { console.error('Missing DOM element: #board'); setStatus && setStatus('Missing #board'); }
  if(!movesList) console.warn('#movesList missing');
  
  // load saves and render
  saves = loadSaves();
  renderSaves();

  // ★ ADD: disable right-click menu for CAD-style panning
  saveCanvas.addEventListener("contextmenu", e => e.preventDefault());

  // ★ ADD: mouse wheel → zoom
  saveCanvas.addEventListener('wheel', onCanvasWheel, { passive: false });

  // ★ ADD: mouse down → start panning (right mouse) or maybe dragging nodes
  saveCanvas.addEventListener('mousedown', onCanvasMouseDown);


  // wire UI listeners (these used to run before DOM ready)
  const undoBtn = document.getElementById('undoBtn');
  const resetBtn = document.getElementById('resetBtn');
  const promoCancel = document.getElementById('promoCancel');

  if(undoBtn) undoBtn.addEventListener('click', () => { if(moveHistory.length===0) return; const last = moveHistory.pop(); gameState = last.state; lastMoveHighlight = []; renderMoves(); renderBoard(); });
  if(resetBtn) resetBtn.addEventListener('click', () => { gameState = fenToBoard(initialFEN); moveHistory=[]; lastMoveHighlight=[]; renderMoves(); renderBoard(); });

  if(promoCancel) promoCancel.addEventListener('click', () => { hidePromotion(); });

  // Saves panel buttons (safe-guarded)
  const saveBtn = document.getElementById('saveBtn');
  const clearSavesBtn = document.getElementById('clearSaves');
  const renameNodeBtn = document.getElementById('renameNode');
  const setBaseBtn = document.getElementById('setBaseBtn');
  const clearBaseBtn = document.getElementById('clearBaseBtn');

  if(saveBtn) saveBtn.addEventListener('click', saveCurrentSnapshot);
  if(clearSavesBtn) clearSavesBtn.addEventListener('click', () => { if(confirm('Clear all saves?')){ saves={}; baseNodeId=null; selectedNodeId=null; persistSaves(); renderSaves(); }});
  if(renameNodeBtn) renameNodeBtn.addEventListener('click', ()=>{ if(!selectedNodeId) return alert('Select a node first by clicking it'); const name = document.getElementById('nodeName').value.trim(); if(!name) return alert('Provide a name'); saves[selectedNodeId].name=name; persistSaves(); renderSaves(); });
  if(setBaseBtn) setBaseBtn.addEventListener('click', ()=>{ if(!selectedNodeId) return alert('Select a node to be base first'); baseNodeId = selectedNodeId; updateBaseIndicator(); });
  if(clearBaseBtn) clearBaseBtn.addEventListener('click', ()=>{ baseNodeId = null; updateBaseIndicator(); });

  // final rendering
  renderMoves();
  renderBoard();
}

function onCanvasWheel(e) {
    e.preventDefault();

    const rect = saveCanvas.getBoundingClientRect();
    const mouseX = (e.clientX - rect.left - cameraX) / cameraScale;
    const mouseY = (e.clientY - rect.top - cameraY) / cameraScale;

    const zoomFactor = -(e.deltaY) * 0.001;
    const newScale = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, cameraScale * (1 + zoomFactor)));

    cameraX -= (mouseX * newScale - mouseX * cameraScale);
    cameraY -= (mouseY * newScale - mouseY * cameraScale);

    cameraScale = newScale;

    applyCameraTransform();
}

let isPanning = false;
let panStartX = 0;
let panStartY = 0;

function onCanvasMouseDown(e) {
    if (e.button === 2) {  // right mouse
        isPanning = true;
        panStartX = e.clientX - cameraX;
        panStartY = e.clientY - cameraY;
    }
}

window.addEventListener('mousemove', e => {
    if (isPanning) {
        cameraX = e.clientX - panStartX;
        cameraY = e.clientY - panStartY;
        applyCameraTransform();
    }
});

window.addEventListener('mouseup', e => {
    if (e.button === 2) isPanning = false;
});

// run init after DOM ready
if(document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

function isInMainChain(parentId, nodeId) {
  if (!parentId || !nodeId) return false;
  let cur = parentId;
  // guard: avoid infinite loops (defensive)
  const visited = new Set();
  while (cur && !visited.has(cur)) {
    if (cur === nodeId) return true;
    visited.add(cur);
    const links = (saves[cur] && saves[cur].links) ? saves[cur].links : [];
    if (links.length === 0) break;
    cur = links[0]; // follow the main forward branch
  }
  return false;
}

// Save snapshot: name automatically by last move (option A)
async function saveCurrentSnapshot(){
  const fen = boardToFEN(gameState);
  const ts = Date.now();
  const id = 'n'+ts;

  // Create miniature snapshot
  const snapshotCanvas = await renderBoardToCanvas();
 const thumbnailCanvas = document.createElement("canvas");
const size = 300;             // match node size
const scale = window.devicePixelRatio || 1;

thumbnailCanvas.width = size * scale;
thumbnailCanvas.height = size * scale;

const ctx = thumbnailCanvas.getContext("2d");
ctx.scale(scale, scale);       // high resolution scaling
const finalSize = 150;

ctx.drawImage(snapshotCanvas,0,0,300,300);
 const imgData = thumbnailCanvas.toDataURL("image/png");

  // Determine name: last move from moveHistory (the move that produced the current state)
  let name = 'start';
  if(moveHistory.length>0){
    const preState = deepClone(moveHistory[moveHistory.length-1].state); // state before last move
    const lastMv = moveHistory[moveHistory.length-1].mv;
    const postState = deepClone(gameState);
    // generate simple SAN-like name from pre/post and mv
    name = simpleMoveNameFromMoveAndState(preState, lastMv, postState);
  }

  // Default coords for display
  const x = 20 + (Object.keys(saves).length%6)*120;
  const y = 20 + Math.floor(Object.keys(saves).length/6)*80;

  // Node structure: keep links for drawing (like original), plus parent for convenience
  const node = { id, name, fen, img: imgData, x, y, links: [], parent: null, created: ts };

// FINAL BRANCH / CONTINUATION LOGIC
// ===============================
// Main chain is defined by following links[0] repeatedly.
function isInMainChain(parentId, lastLoadedId, saves) {
  if (!parentId || !lastLoadedId) return false;

  // main chain = follow links[0] only
  let cur = parentId;

  // skip the parent itself (do NOT treat parent as continuation)
  const visited = new Set();

  while (true) {
    const children = saves[cur].links || [];

    // tail? then no continuation possible
    if (children.length === 0) return false;

    const next = children[0];

    if (next === lastLoadedId) {
      return true;   // lastLoaded lies on continuation chain
    }

    // avoid loop
    if (visited.has(next)) return false;
    visited.add(next);

    cur = next;
  }
}

// Insert new node `id` (node object in variable `node`) when baseNodeId is set:
if (baseNodeId && saves[baseNodeId]) {
  const parentId = baseNodeId;

  // ensure parent's links array exists
  saves[parentId].links = saves[parentId].links || [];
  const oldChildren = saves[parentId].links.slice(); // copy for safety

  // CASE 1: parent has no children -> attach as first child (start chain)
  if (oldChildren.length === 0) {
    node.parent = parentId;
    node.links = [];
    saves[parentId].links = [id];
  }

  // CASE 2: continuation on main chain -> lastLoadedNode lies on the parent's main chain
  // We need to find the tail of that main chain (follow links[0]) and attach the new node
  // as the new first-child (continuation) of the tail.
  else if (isInMainChain(parentId, lastLoadedNode, saves)) {
    // find tail by following first-child chain until a node has no first child
    let tailId = parentId;
    while (saves[tailId].links && saves[tailId].links.length > 0 && saves[tailId].links[0]) {
      tailId = saves[tailId].links[0];
    }

    // Put new node as the first child of the tail (continues the chain)
    // Preserve any other children tail may have (they become siblings after index 0)
    node.parent = tailId;
    node.links = [];
    saves[tailId].links = saves[tailId].links || [];
    // insert as first child
    saves[tailId].links = [ id, ...saves[tailId].links ];
  }

  // CASE 3: fork/splice (lastLoadedNode is NOT on the main chain)
  // Insert the new node as the SECOND child (index 1) of parentId so the original
  // main-chain child at index 0 remains the continuation; the new branch becomes the
  // second straight branch (and will use links[0] to continue).
  else {
    // ensure parent has at least the first child
    const firstChild = oldChildren[0];

    node.parent = parentId;
    node.links = []; // new branch head has no children yet

    if (!firstChild) {
      // weird case (shouldn't happen because oldChildren.length > 0), but handle cleanly
      saves[parentId].links = [ id, ...oldChildren.slice(1) ];
    } else {
      // keep first child intact at index 0, insert new node at index 1
      const rest = oldChildren.slice(1); // children after first
      saves[parentId].links = [ firstChild, id, ...rest ];
    }
  }

  // persist node and mark active
  saves[id] = node;
  lastLoadedNode = id;
}
if (!saves[id]) {
    saves[id] = node;
}

  persistSaves();
  renderSaves();
}

function updateBaseIndicator(){
  const el = document.getElementById('baseIndicator');
  const nameEl = document.getElementById('baseName');
  if(baseNodeId && saves[baseNodeId]){ el.style.display='inline'; nameEl.innerText = saves[baseNodeId].name; } else { el.style.display='none'; nameEl.innerText=''; }
}

function persistSaves(){ localStorage.setItem('chess_saves', JSON.stringify(saves)); }
function loadSaves(){ try{ return JSON.parse(localStorage.getItem('chess_saves')||'{}'); }catch(e){return{}} }

function renderSaves() {
    // Clear existing canvas
    saveCanvas.innerHTML = '';


  // --- CREATE TRANSFORM WRAPPER ---
    const wrapper = document.createElement('div');
    wrapper.id = 'transformWrapper';
    wrapper.style.position = 'absolute';
    wrapper.style.left = '0';
    wrapper.style.top = '0';
    wrapper.style.width = '100%';
    wrapper.style.height = '100%';
    wrapper.style.transformOrigin = '0 0';
    saveCanvas.appendChild(wrapper);

    // --- CREATE SVG FOR CONNECTIONS ---
    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('class','connections');
    svg.setAttribute('id','connections');
    svg.style.position = 'absolute';
    svg.style.left = 0;
    svg.style.top = 0;
    svg.style.width = '100%';
    svg.style.height = '100%';
svg.style.overflow = "visible";
    svg.style.pointerEvents = "none";
    wrapper.appendChild(svg);

    // --- RENDER NODES ---
    for (const id in saves) {
        const node = saves[id];
        const el = document.createElement('div');

        el.className = 'node';
        el.style.position = 'absolute';
        el.style.left = node.x + 'px';
        el.style.top = node.y + 'px';
        el.id = 'node-' + id;

        el.innerHTML = `<img src="${node.img}" class="thumb" draggable="false">`;

        el.title = node.name;
        el.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;  // only left mouse
    e.stopPropagation();
    startDragNode(id)(e);
});
        el.addEventListener('click', (e) => {
            e.stopPropagation();
            selectNode(id);
        });

        wrapper.appendChild(el);
    }

    // Apply camera transform (zoom + pan)
    applyCameraTransform();

    // Draw connections using SVG inside wrapper
    drawConnections(svg);

    updateBaseIndicator();
}

saveCanvas.addEventListener('wheel', (e) => {
    e.preventDefault();

    // Get cursor position relative to wrapper
    const rect = saveCanvas.getBoundingClientRect();
    const offsetX = (e.clientX - rect.left - cameraX) / cameraScale ;
    const offsetY = (e.clientY - rect.top - cameraY) / cameraScale ;

    // Zoom direction
    const zoomAmount = -e.deltaY * 0.001;
    const newScale = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, cameraScale * (1 + zoomAmount)));

    // Adjust camera so zoom is centered on cursor
    cameraX -= (offsetX * newScale - offsetX * cameraScale);
    cameraY -= (offsetY * newScale - offsetY * cameraScale);

    cameraScale = newScale;
    applyCameraTransform();
}, { passive: false });

function selectNode(id){
  selectedNodeId = id;
lastLoadedNode = id;
  document.getElementById('nodeName').value = saves[id].name;
  const fen = saves[id].fen;
  gameState = fenToBoard(fen);
  // clear live moveHistory when loading snapshot to match original behavior
  moveHistory = [];
  lastMoveHighlight = [];
  renderBoard();
}

// Drag node handlers

function startDragNode(id){ console.log("START DRAG FOR NODE", id); return function(e){ e.stopPropagation();e.preventDefault(); dragInfo={id,ox:(e.clientX - cameraX)/cameraScale,oy:(e.clientY - cameraY)/ cameraScale ,startX:saves[id].x,startY:saves[id].y}; document.addEventListener('mousemove',onDragNode); document.addEventListener('mouseup',stopDragNode); } }
function onDragNode(e){
   console.log("DRAGGING", dragInfo);
    if (!dragInfo) return;

    const worldX = (e.clientX - cameraX) / cameraScale;
    const worldY = (e.clientY - cameraY) / cameraScale;

    const dx = worldX - dragInfo.ox;
    const dy = worldY - dragInfo.oy;

    saves[dragInfo.id].x = dragInfo.startX + dx;
    saves[dragInfo.id].y = dragInfo.startY + dy;

    // Update DOM position
    const el = document.getElementById("node-" + dragInfo.id);
    if (el) {
        el.style.left = saves[dragInfo.id].x + "px";
        el.style.top  = saves[dragInfo.id].y + "px";
    }

    drawConnections(document.getElementById("connections"));
}function stopDragNode(e){ dragInfo=null; document.removeEventListener('mousemove',onDragNode); document.removeEventListener('mouseup',stopDragNode); }

// clicking empty area deselect
saveCanvas.addEventListener('click',()=>{ selectedNodeId=null; document.getElementById('nodeName').value=''; });

function getNodeAnchors(node) {
  const w = 150;      // your node width
  const h =150;      // approx height (90px image + padding)
  const x = node.x;
  const y = node.y;

  return {
    top:    { x: x + w/2,     y: y },
    bottom: { x: x + w/2,     y: y + h },
    left:   { x: x,           y: y + h/2 },
    right:  { x: x + w,       y: y + h/2 }
  };
}

// Drawing connections (parent->child using links array)
function drawConnections(svgElement){
  // if svgElement not passed, try to get current connections element
  const svg = svgElement || document.getElementById('connections');
  if(!svg) return;
  svg.innerHTML = '';
  for(const id in saves){
    const node = saves[id];
    if(node.links && node.links.length>0){
      for(const childId of node.links){
        const child = saves[childId];
        if(!child) continue;

        const parentAnchors = getNodeAnchors(node);
const childAnchors  = getNodeAnchors(child);

let start, end;

// determine direction
if (child.y > node.y + 50) {
    // child is below
    start = parentAnchors.bottom;
    end   = childAnchors.top;
} else if (child.y + 50 < node.y) {
    // child is above
    start = parentAnchors.top;
    end   = childAnchors.bottom;
} else if (child.x > node.x) {
    // child is to the right
    start = parentAnchors.right;
    end   = childAnchors.left;
} else {
    // child is to the left
    start = parentAnchors.left;
    end   = childAnchors.right;
}

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");

const c1x = start.x + (end.x - start.x) * 0.3;
const c1y = start.y + (end.y - start.y) * 0.3;
const c2x = start.x + (end.x - start.x) * 0.7;
const c2y = start.y + (end.y - start.y) * 0.7;

path.setAttribute("d", `M ${start.x} ${start.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${end.x} ${end.y}`);
path.setAttribute("stroke", "#2b6cb0");
path.setAttribute("stroke-width", "2");
path.setAttribute("fill", "none");

svg.appendChild(path);
      }
    }
  }
}

// helper used for castling path safety (same as original)
function isAttacked(squareR, squareF, byColor){
  const snapshot = saveStateForTest(); const saveTurn = gameState.turn; gameState.turn = byColor; const moves = generateAllLegalMoves(byColor); gameState.turn = saveTurn; restoreStateFromTest(snapshot);
  return moves.some(m=>m.to[0]===squareR && m.to[1]===squareF);
}


</script>
</body>
</html>

