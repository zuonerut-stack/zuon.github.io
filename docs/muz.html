<!doctype html>
<html lang="en">
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini MIDI Piano Roll</title>
  <style>
  .chord-ui{
  display:flex; gap:4px; position:absolute; z-index:1000; pointer-events:auto;
  background:rgba(19,34,62,0.95); padding:4px 6px; border-radius:6px; box-shadow:0 2px 6px rgba(0,0,0,0.5);
  font-size:12px;
}
.chord-ui button{
  background:#13223e; color:#dfe7ff; border:none; padding:2px 6px; border-radius:4px; cursor:pointer;
}
.key.highlight{ background: orange !important; }


    
    :root{
      --cell-w:24px;
      --cell-h:22px;
      --keys-w:84px;
      --rows:84;
    }
    .keys, .key, .row, .cell {
  box-sizing: border-box;
}
.key, .row {
  height: var(--cell-h); /* border included */
  border-bottom: 1px solid transparent; /* optional to match */
}
.keys { height: calc(var(--rows) * var(--cell-h)); }
.grid { height: calc(var(--rows) * var(--cell-h)); }/*hotfix*/
    body{font-family:Inter,system-ui,Arial;margin:0;background:#0b1020;color:#dfe7ff}
    .app{display:flex;flex-direction:column;height:100vh}
    header{display:flex;gap:12px;align-items:center;padding:8px;background:#071025}
    header h1{margin:0;font-size:16px}
    .controls{display:flex;gap:8px;align-items:center}
    button, select, input[type=number]{background:#0f1830;color:#eaf0ff;border:1px solid #1f2a45;padding:6px;border-radius:6px}
    .main{flex:1;display:flex;overflow:hidden}
    .left{width:var(--keys-w);background:#081226;border-right:1px solid #18273f;overflow:auto}
    .keys{display:flex;flex-direction:column}
    .key{height:var(--cell-h);display:flex;align-items:center;justify-content:center;border-bottom:1px solid #0f2338;cursor:pointer;user-select:none}
    .white{background:linear-gradient(180deg,#f6f6f8 0,#eef1ff 100%);color:#071022}
    .black{background:linear-gradient(180deg,#1b2335 0,#0b1424 100%);color:#dfe7ff}
    .roll-wrap{flex:1;position:relative;overflow:auto}

    .viewport{position:relative;min-width:800px}
    .grid{display:block;position:relative;transform:translateX(0);transition:transform 0.03s linear}
    .row{display:flex}
    .cell{width:var(--cell-w);height:var(--cell-h);box-sizing:border-box;border-right:1px solid rgba(255,255,255,0.03);border-bottom:1px solid rgba(255,255,255,0.02);}

    .note{position:absolute;height:var(--cell-h);background:linear-gradient(90deg,#79c2ff,#4a9cff);border-radius:4px;box-shadow:0 2px 6px rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;color:#021b31;font-weight:600;font-size:12px}
    .playhead{position:absolute;top:0;bottom:0;width:2px;background:#ffde59;left:30px;transform:translateX(-1px);z-index:30}
    footer{padding:8px;background:#071025;display:flex;align-items:center;gap:8px}
    .notes-list{padding:8px;color:#9fb2ff;max-height:120px;overflow:auto}
    input[type=file]{display:none}
    .badge{background:#13223e;padding:4px 8px;border-radius:6px}
    .slider{width:320px}
    label{font-size:13px;color:#bcd1ff}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Mini MIDI Piano Roll</h1>
      <div class="controls">
        <select id="instrumentSelect">
  <option value="piano">Piano</option>
  <option value="string">String</option>
</select>
        <button id="toggleMode">Switch to Player Mode</button>
        <label class="badge">BPM <input id="bpm" type="number" min="20" max="400" value="120" style="width:64px;margin-left:6px"></label>
        <button id="playPause">Play</button>
        <label style="display:flex;align-items:center;gap:6px"><span style="font-size:13px">Start pos</span><input id="seek" type="range" min="0" max="512" value="0" class="slider"></label>
        <button id="save">Save</button>
        <button id="loadBtn">Load</button>
        <input id="filein" type="file" accept="application/json">
        <button id="clear">Clear</button>
      </div>
    </header>

    <div class="main">
    
    
    
      <div class="left">
        <div class="keys" id="keys"></div>
      </div>
      <div class="roll-wrap" id="wrap">
        <div class="viewport" id="viewport">
          <div class="playhead" id="playhead"></div>
          <div class="grid" id="grid"></div>
        </div>
      </div>
    </div>
    
  <script>
  (function(){
    let harpLoaded = false;
    const harpSampler = new Tone.Sampler({
  urls: {
    B2:'B2.mp3',
    Eb3: 'Eb3.mp3',
    Bb3: 'Bb3.mp3',
    F4: 'F4.mp3',
    C5: 'C5.mp3',
    G5: 'G5.mp3',
    D6: 'D6.mp3',
  },
  baseUrl: './',
  onload: () => {
  harpLoaded = true;
  console.log("Harp samples loaded!");
}
}).toDestination();
    const synth = new Tone.PolySynth(Tone.Synth, {
  oscillator: { type: "triangle" },  // try "sine", "square", "triangle", "sawtooth"
  envelope: {
    attack: 0.01,
    decay: 0.1,
    sustain: 0.3,
    release: 1
  }
}).toDestination();
synth.volume.value = 2;
    //const synth = new Tone.Synth().toDestination();//
    
    const OCT_LOW = 1;
    const OCT_HIGH = 7;
    const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

    const pitches = [];
    for(let o=OCT_LOW; o<=OCT_HIGH; o++){
      for(let i=0;i<12;i++){
        pitches.push({name: NOTE_NAMES[i]+o, noteIndex: i, octave: o});
      }
    }

    const rowsPitches = pitches.slice().reverse();

    const beatsVisible = 64;
    const totalBeats = 1024;
    const cellW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-w')) || 24;
    const cellH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-h')) || 22;

    const rows = rowsPitches.length;
    document.documentElement.style.setProperty('--rows', rows);
    
    const gridEl = document.getElementById('grid');
    const keysEl = document.getElementById('keys');
    const viewport = document.getElementById('viewport');
    const bpmInput = document.getElementById('bpm');
    const toggleModeBtn = document.getElementById('toggleMode');
    //const modeInfo = document.getElementById('modeInfo');
    const playBtn = document.getElementById('playPause');
    const saveBtn = document.getElementById('save');
    const loadInput = document.getElementById('filein');
    const loadBtn = document.getElementById('loadBtn');
    const clearBtn = document.getElementById('clear');
    /*const notesList = document.getElementById('notesList');*/
    const seek = document.getElementById('seek');

    let editorMode = true;
    let playing = false;
    let bpm = parseFloat(bpmInput.value) || 120;
    let transportPos = 0;
    let audioCtx = null;

    let notes = [];
    let nextNoteId = 1;

    function buildKeys(){
      keysEl.innerHTML = '';
      for(let r=0;r<rows;r++){
        const pitch = rowsPitches[r];
        const isSharp = pitch.name.includes('#');
        const k = document.createElement('div');
        k.className = 'key ' + (isSharp? 'black':'white');
        k.textContent = pitch.name;
        k.dataset.row = r;
        k.addEventListener('click', ()=>playImmediatePitch(r));
        keysEl.appendChild(k);
      }
    }

    function buildGrid(){
      gridEl.style.width = (totalBeats * cellW) + 'px';
      gridEl.innerHTML = '';
      for(let r=0;r<rows;r++){
        const row = document.createElement('div');
        row.className = 'row';
        row.style.position = 'relative';
        row.style.height = cellH + 'px';
        row.dataset.row = r;
        for(let b=0;b<totalBeats;b++){
          const c = document.createElement('div');
          c.className = 'cell';
          c.dataset.row = r;
          c.dataset.beat = b;
          row.appendChild(c);
        }
        gridEl.appendChild(row);
      }
    }

    function renderNotes(){
      const existing = gridEl.querySelectorAll('.note');
      existing.forEach(n=>n.remove());
      for(const n of notes){
        const top = n.pitchRow * cellH;
        const left = n.start * cellW;
        const w = Math.max(1, n.length) * cellW - 4;
        const el = document.createElement('div');
        el.className = 'note';
        el.style.top = top + 'px';
        el.style.left = left + 'px';
        el.style.width = w + 'px';
        const label = rowsPitches[n.pitchRow] ? rowsPitches[n.pitchRow].name : '';
        el.textContent = label;
        el.dataset.id = n.id;
        gridEl.appendChild(el);
      }
      updateNotesList();
    }

    function updateNotesList(){
      if(notes.length===0){ notesList.textContent='No notes'; return; }
      notesList.innerHTML='';
      const copy = notes.slice().sort((a,b)=>a.start-b.start);
      for(const n of copy){
        const div = document.createElement('div');
        const label = rowsPitches[n.pitchRow] ? rowsPitches[n.pitchRow].name : '?';
        div.textContent = `${label} @ ${n.start} len ${n.length}`;
        notesList.appendChild(div);
      }
    }

    function ensureAudio(){
      if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function noteToMidi(noteName){
      const m = noteName.match(/^([A-G])(#?)(\d+)$/);
      if(!m) return 69;
      const letter = m[1];
      const sharp = m[2] === '#';
      const octave = parseInt(m[3],10);
      const base = {'C':0,'D':2,'E':4,'F':5,'G':7,'A':9,'B':11}[letter];
      const idx = base + (sharp?1:0);
      const midi = (octave + 1) * 12 + idx;
      return midi;
    }

    function midiToFreq(m){
      return 440 * Math.pow(2, (m - 69)/12);
    }
    
    let scheduledUntil = 0;
    
    function scheduleFromPosition(beatPos){
  if(!Tone.context) return;
  const secondsPerBeat = 60 / bpm;
  const secondsPerCell = secondsPerBeat / 4;
  const lookaheadBeats = Math.ceil((5) / secondsPerCell);
  const startBeat = Math.floor(beatPos);
  const endBeat = startBeat + lookaheadBeats;
  if(endBeat <= scheduledUntil) return;

  for(const n of notes){
    if(n.start >= scheduledUntil && n.start < endBeat){
      const timeFromNow = (n.start - beatPos) * secondsPerCell;
      const duration = Math.max(0.01, n.length * secondsPerCell);

      const noteName = rowsPitches[n.pitchRow].name;
      
playImmediatePitch(n.pitchRow, timeFromNow, duration);
}
}

  scheduledUntil = endBeat;
  }

function playImmediatePitch(rowIdx, timeFromNow = 0, duration = 0.5){
  const pitch = rowsPitches[rowIdx];
  if(!pitch) return;

  const noteName = pitch.name;

  // Ensure context is running, and only then trigger the note
  Tone.start().then(() => {
    if (currentInstrument === 'piano') {
      synth.triggerAttackRelease(
        noteName,
        Tone.Time(duration).toSeconds(),
        Tone.now() + timeFromNow
      );
    } else if (currentInstrument === 'string' && harpLoaded) {
      harpSampler.triggerAttackRelease(
        noteName,
        Tone.Time(duration).toSeconds(),
        Tone.now() + timeFromNow
      );
    }
  }).catch(e => console.warn("Tone.js failed to start:", e));
}
    function getGridTransformX(){
      const st = getComputedStyle(gridEl).transform;
      if(!st || st === 'none') return 0;
      const m = st.match(/matrix\(([^,]+),[^,]+,[^,]+,[^,]+,([^,]+),/);
      if(m && m[2]) return parseFloat(m[2]);
      const mm = st.match(/matrix3d\(([^,]+),[^,]+,[^,]+,[^,]+,[^,]+,[^,]+,[^,]+,[^,]+,[^,]+,[^,]+,[^,]+,[^,]+,([^,]+),/);
      if(mm && mm[2]) return parseFloat(mm[2]);
      return 0;
    }

    function clientToGrid(e){
      const rect = gridEl.getBoundingClientRect();
      const tx = getGridTransformX();
      const x = e.clientX - rect.left - tx;
      const y = e.clientY - rect.top;
      const beat = Math.floor(x / cellW);
      let row = Math.floor(y / cellH);
      if(row < 0) row = 0; if(row >= rows) row = rows-1;
      return {beat: Math.max(0, beat), row};
    }

    let isMouseDown = false;
    let dragInfo = null;

    gridEl.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      const pos = clientToGrid(e);
      const row = pos.row;
      const beat = pos.beat;
      const idx = notes.findIndex(n=>n.pitchRow===row && n.start<=beat && beat < n.start + n.length);
      if(idx >= 0){ notes.splice(idx,1); renderNotes(); }
    });

    gridEl.addEventListener('mousedown', (e)=>{
      if(!editorMode) return;
      if(e.button !== 0) return;
      const pos = clientToGrid(e);
      const row = pos.row; const beat = pos.beat;
      isMouseDown = true;
      const n = {id: nextNoteId++, pitchRow: row, start: beat, length: 1};
      notes.push(n);
      dragInfo = {noteId: n.id, startBeat: beat};
      renderNotes();
    });

    window.addEventListener('mousemove', (e)=>{
      if(!isMouseDown || !dragInfo) return;
      const pos = clientToGrid(e);
      const beat = pos.beat;
      const n = notes.find(x=>x.id===dragInfo.noteId);
      if(!n) return;
      const newLen = Math.max(1, beat - dragInfo.startBeat + 1);
      n.length = Math.min(256, newLen);
      renderNotes();
    });

    window.addEventListener('mouseup', ()=>{ isMouseDown = false; dragInfo = null; });

    gridEl.addEventListener('click', (e)=>{
      if(!editorMode) return;
    });

    viewport.addEventListener('click', (e)=>{
      if(editorMode) return;
      const pos = clientToGrid(e);
      transportPos = Math.max(0, pos.beat);
      gridEl.style.transform = `translateX(${-(transportPos*cellW)}px)`;
      seek.value = Math.max(0, Math.min(parseInt(seek.max), transportPos));
      scheduledUntil = Math.floor(transportPos);
    });

    let rafId = null;
    let startTime = 0;
    let startTransport = 0;

    function tick(){
  if(playing){
    const now = Tone.context.currentTime;
    const secondsPerBeat = 60 / bpm;
    const secondsPerCell = secondsPerBeat / 4;
    const elapsed = now - startTime;
    transportPos = startTransport + (elapsed / secondsPerCell);

    // Stop automatically if beyond last note
    const lastEnd = getLastNoteEnd();
    if(transportPos >= lastEnd){
      playing = false;
      playBtn.textContent = 'Play';
      synth.releaseAll(); // stop lingering sounds
      transportPos = lastEnd; // optional: stop exactly at last note
    }

    // Move grid/playhead
    gridEl.style.transform = `translateX(${-(transportPos*cellW)}px)`;
    scheduleFromPosition(transportPos);
    seek.value = Math.max(0, Math.min(parseInt(seek.max), Math.floor(transportPos)));
  }
  rafId = requestAnimationFrame(tick);
}

    toggleModeBtn.addEventListener('click', ()=>{
      editorMode = !editorMode;
      toggleModeBtn.textContent = editorMode? 'Switch to Player Mode':'Switch to Editor Mode';
    });

playBtn.addEventListener('click', async () => {
  if (!playing) {
    ensureAudio();
    await Tone.start(); // <-- add this line
    playing = true;
    playBtn.textContent = 'Stop';
    startTransport = transportPos;
    startTime = Tone.now();
    scheduledUntil = Math.floor(transportPos);
    scheduleFromPosition(transportPos);
  } else {
    playing = false;
    playBtn.textContent = 'Play';

    // Stop all notes immediately
    synth.releaseAll();

    // Reset transport position
    transportPos = 0;
    startTransport = 0;
    scheduledUntil = 0;

    // Reset grid/playhead
    gridEl.style.transform = `translateX(0px)`;
    seek.value = 0;
  }
});

    bpmInput.addEventListener('change', ()=>{ bpm = parseFloat(bpmInput.value) || 120; });

    seek.addEventListener('input', ()=>{
      const val = parseInt(seek.value,10) || 0;
      transportPos = val;
      if(!playing){ gridEl.style.transform = `translateX(${-(transportPos*cellW)}px)`; }
      else { startTransport = transportPos; startTime = audioCtx ? audioCtx.currentTime : performance.now()/1000; }
      scheduledUntil = Math.floor(transportPos);
    });

    saveBtn.addEventListener('click', ()=>{
      const payload = {notes, bpm};
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'piano_roll.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    loadBtn.addEventListener('click', ()=>loadInput.click());
    loadInput.addEventListener('change', (ev)=>{
      const file = ev.target.files[0]; if(!file) return;
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const obj = JSON.parse(reader.result);
          if(obj.notes && Array.isArray(obj.notes)){
            notes = obj.notes.map(n=>({id:n.id||nextNoteId++, pitchRow:n.pitchRow, start:n.start, length:n.length}));
            bpm = obj.bpm || bpm; bpmInput.value = bpm;
            renderNotes();
            scheduledUntil = Math.floor(transportPos);
          }
        }catch(e){ alert('Error reading file'); }
      };
      reader.readAsText(file);
    });

    clearBtn.addEventListener('click', ()=>{ if(confirm('Clear all notes?')){ notes=[]; renderNotes(); } });

    buildKeys(); buildGrid(); renderNotes();
    seek.max = totalBeats;
    scheduledUntil = 0;
    tick();
let currentInstrument = 'piano';

document.getElementById('instrumentSelect').addEventListener('change', e => {
  currentInstrument = e.target.value;
}); // keep the current instument


const left = document.querySelector('.left');
const rollWrap = document.querySelector('.roll-wrap');

// Sync vertical scroll
rollWrap.addEventListener('scroll', () => {
  left.scrollTop = rollWrap.scrollTop;
});

left.addEventListener('scroll', () => {
  rollWrap.scrollTop = left.scrollTop;
});

function getLastNoteEnd() {
  if(notes.length === 0) return 0;
  return Math.max(...notes.map(n => n.start + n.length));
}

  })();

    //feature update

(function(){
  const chordUI = document.createElement('div');
  chordUI.className = 'chord-ui';
  chordUI.style.display = 'none';
  document.body.appendChild(chordUI);

  const chordTypes = [
    {label:'X', type:'maj'},
    {label:'Xm', type:'min'},
    {label:'Xaug', type:'aug'},
    {label:'Xsus', type:'sus'},
    {label:'Xdim', type:'dim'}
  ];

  chordTypes.forEach(c=>{
    const btn = document.createElement('button');
    btn.textContent = c.label;
    btn.dataset.type = c.type;
    chordUI.appendChild(btn);

    btn.addEventListener('mouseenter', ()=>{
      if(!hoveredNote) return;
      highlightChord(getNoteNameFromRow(hoveredNote.pitchRow), c.type);
    });
  });

  function getNoteNameFromRow(row){
    return rowsPitches[row].name;
  }

  function getChordNotes(root, chordType){
    const semitoneMap = {
      'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11
    };
    const intervals = {
      maj:[0,4,7],
      min:[0,3,7],
      aug:[0,4,8],
      sus:[0,5,7],
      dim:[0,3,6]
    };
    const m = root.match(/^([A-G]#?)(\d+)$/);
    if(!m) return [];
    const rootName = m[1], octave = parseInt(m[2]);
    const base = semitoneMap[rootName];
    const notes = [];
    for(let oct=octave-1; oct<=octave+1; oct++){
      intervals[chordType].forEach(i=>{
        notes.push(base + i + oct*12);
      });
    }
    return notes;
  }

  function highlightChord(root, chordType){
    const chordNotes = getChordNotes(root, chordType);
    const keyEls = document.querySelectorAll('.key');
    keyEls.forEach(k=>{
      const midi = noteToMidi(k.textContent);
      if(chordNotes.includes(midi)) k.classList.add('highlight');
      else k.classList.remove('highlight');
    });
  }

  let hoveredNote = null;

  function attachHoverToNotes(){
    const noteEls = document.querySelectorAll('.note');
    noteEls.forEach(n=>{
      n.addEventListener('mouseenter', ()=> {
        hoveredNote = notes.find(x=>x.id == n.dataset.id);
        const rect = n.getBoundingClientRect();
        chordUI.style.left = rect.left + 'px';
        chordUI.style.top = rect.bottom + 2 + 'px';
        chordUI.style.display = 'flex';
      });
      n.addEventListener('mouseleave', ()=>{
        hoveredNote = null;
        chordUI.style.display = 'none';
        document.querySelectorAll('.key').forEach(k=>k.classList.remove('highlight'));
      });
    });
  }

  // Reattach hover whenever notes are rendered
  const originalRenderNotes = renderNotes;
  renderNotes = function(){
    originalRenderNotes();
    attachHoverToNotes();
  };
})();
  </script>
</body>

</html>









