<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chess Study v0.8</title>
<style>
:root{
  --board-size:min(100vh,100vw);
  --square-size: calc(var(--board-size) / 8);
}
body{font-family: Inter, system-ui, Arial; background:#f2efe9; margin:20px; color:#222}
.app{display:flex;gap:24px;align-items:flex-start}
.board-wrap{background:linear-gradient(180deg,#e6d9c3,#d7c4a6);padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.12)}
.board{aspect-ratio: 1 / 1;
  width: --board-size;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows: repeat(8, 1fr);border-radius:6px;overflow:hidden;position:relative}
.square{width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:30px;user-select:none}
.square.light{background:linear-gradient(180deg,#fdf5e9,#f7e9d1)}
.square.dark{background:linear-gradient(180deg,#c49663,#8f5b33)}
.square.highlight{outline:4px solid rgba(255,255,0,0.45);box-sizing:border-box}
.square.last-move{box-shadow:inset 0 0 40px rgba(255,255,255,0.06)}
.coords{position:absolute;left:6px;top:6px;font-size:12px;color:rgba(0,0,0,0.45)}
.controls{width:420px}
.controls .panel{background:white;padding:12px;border-radius:10px;box-shadow:0 6px 14px rgba(0,0,0,0.06);margin-bottom:12px}
.btn{display:inline-block;padding:8px 12px;border-radius:8px;background:#2b6cb0;color:white;text-decoration:none;cursor:pointer}
.btn.secondary{background:#718096}
.piece {
  font-size: min(10vw, 48px);
  line-height: 1;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:grab;
}
.row{display:flex;gap:8px;align-items:center}
.meta{font-size:13px;color:#444}
.moves-list{max-height:140px;overflow:auto;padding:8px;border-radius:8px;background:#fbfbfb}
.board-options{display:flex;gap:8px;margin-bottom:8px}
.save-stage{background:#ffffff;padding:10px;border-radius:10px;min-height:220px}
.save-item{background:#f7f7f8;padding:8px;border-radius:8px;margin:6px;display:inline-block;cursor:grab}
.save-toolbar{display:flex;gap:8px;flex-wrap:wrap}
.save-canvas{position:relative;width:100%;height:260px;border-radius:8px;background:linear-gradient(180deg,#fffafa,#f6fcff);overflow:auto}
.node{position:absolute;padding:8px 12px;border-radius:8px;background:#fff;border:1px solid #ddd;box-shadow:0 6px 12px rgba(0,0,0,0.06);cursor:grab;min-width:80px;text-align:center}
.node .title{font-weight:600;font-size:13px}
.node small{display:block;color:#666;margin-top:4px}
svg.connections{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
.notice{font-size:13px;color:#666}
.promotion-modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:white;padding:14px;border-radius:10px;box-shadow:0 20px 50px rgba(0,0,0,0.2)}
.promotion-modal button{margin:6px}
.footer{font-size:12px;color:#666;margin-top:8px}
.base-indicator{font-size:12px;color:#2b6cb0;margin-left:8px}
</style>
</head>
<body>
<div class="app">
  <div class="board-wrap">
    <div class="coords">a1 - h8 (drag pieces or click)</div>
    <div id="board" class="board"></div>
    <div style="margin-top:10px;display:flex;gap:8px;justify-content:space-between;align-items:center">
      <div class="meta"><span id="turnLabel">White to move</span> • <span id="statusLabel">Ready</span></div>
      <div>
        <button class="btn" id="undoBtn">Undo</button>
        <button class="btn secondary" id="resetBtn">Reset</button>
      </div>
    </div>
  </div>
  <div class="controls">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="font-weight:700">Game Controls</div>
        <div class="notice">Board style: wooden (editable in CSS). You can switch background image with the 'Upload' control later.</div>
      </div>
      <div class="row board-options">
        <label><input type="checkbox" id="legalOnly" checked> Enforce legal moves</label>
        <label><input type="checkbox" id="showCoords" checked> Show coords</label>
      </div>
      <div style="margin-top:8px" class="row">
        <div class="moves-list" id="movesList">Moves will appear here.</div>
      </div>
    </div>

    <div class="panel save-stage">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">Save & Lines (Snapshots)</div>
        <div class="save-toolbar">
          <button class="btn" id="saveBtn">Save Snapshot</button>
          <button class="btn secondary" id="clearSaves">Clear Saves</button>
        </div>
      </div>
      <div style="margin-top:8px" class="save-canvas" id="saveCanvas">
        <svg class="connections" id="connections"></svg>
      </div>
      <div style="margin-top:8px">
        <div class="notice">Click a node to load that snapshot. Drag nodes to arrange. Use 'Set Base' to define which node becomes the ancestor for newly created nodes (branching).</div>
      </div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <input id="nodeName" placeholder="name for selected node" style="flex:1;padding:8px;border-radius:8px;border:1px solid #ddd" />
        <button class="btn" id="renameNode">Rename</button>
        <!-- Set base controls -->
        <button class="btn secondary" id="setBaseBtn">Set Base</button>
        <button class="btn secondary" id="clearBaseBtn">Clear Base</button>
        <span class="base-indicator" id="baseIndicator" style="display:none">Base: <span id="baseName"></span></span>
      </div>
    </div>

    <div class="panel">
      <div style="font-weight:700;margin-bottom:6px">Help</div>
      <div class="meta">This is a single-file HTML project that implements a chess board with legal move enforcement (including pins and checks), en passant, castling both sides, promotion, and a snapshot/graph system to save positions and connect them into lines.</div>
      <div class="footer">Tips: Save positions frequently. Use labels to create lines (openings, tactical motifs).</div>
    </div>
  </div>
</div>

<div id="promotionModal" class="promotion-modal" style="display:none">
  <div style="font-weight:700;margin-bottom:8px">Choose promotion piece</div>
  <div id="promoButtons"></div>
  <div style="text-align:right;margin-top:8px"><button class="btn secondary" id="promoCancel">Cancel</button></div>
</div>

<script>
/*
  Modified Save & Nodes logic:
  - Snapshot names default to the last move (option A)
  - 'Set Base' button makes the selected node the base ancestor for future saves
  - Automatic parent-child creation: new nodes attach under the most-recent descendant of base
  - Connections drawn automatically from parent -> child; manual linking removed
*/

// --- Utilities (kept from original file)
const PIECES = { p:'pawn', r:'rook', n:'knight', b:'bishop', q:'queen', k:'king' };
const initialFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

function fenToBoard(fen){
  const [placement, turn, castling, ep] = fen.split(' ');
  const rows = placement.split('/');
  let board = Array.from({length:8},()=>Array(8).fill(null));
  for(let r=0;r<8;r++){
    let file=0;
    for(const ch of rows[r]){
      if(/[1-8]/.test(ch)){ file+=parseInt(ch); }
      else { board[r][file]=ch; file++; }
    }
  }
  return {board, turn: turn==='w'?'w':'b', castling: castling==='-'? '': castling, ep: ep==='-'?null:ep };
}
function boardToFEN(state){
  let out='';
  for(let r=0;r<8;r++){
    let empty=0;
    for(let f=0;f<8;f++){
      const p = state.board[r][f];
      if(!p) empty++; else { if(empty){ out+=empty; empty=0;} out+=p; }
    }
    if(empty) out+=empty;
    if(r<7) out+='/';
  }
  const turn = state.turn;
  const castling = state.castling || '-';
  const ep = state.ep || '-';
  return `${out} ${turn} ${castling} ${ep} 0 1`;
}

function algebraic(r,f){ return 'abcdefgh'[f] + (8-r); }
function fromAlg(s){ const f='abcdefgh'.indexOf(s[0]); const r=8-parseInt(s[1]); return [r,f]; }

// Initialize board state
let gameState = fenToBoard(initialFEN);
let moveHistory = [];
let selected = null; // {r,f}
let legalOnly=true;
let lastMoveHighlight = [];

// Castling rights
if(!gameState.castling) gameState.castling='KQkq';

// --- Rendering (same as original)
const boardEl = document.getElementById('board');
const turnLabel = document.getElementById('turnLabel');
const statusLabel = document.getElementById('statusLabel');
const movesList = document.getElementById('movesList');

function renderBoard(){
  boardEl.innerHTML='';
  for(let r=0;r<8;r++){
    for(let f=0;f<8;f++){
      const sq=document.createElement('div');
      sq.className='square '+(((r+f)%2) ? 'dark':'light');
      sq.dataset.r=r; sq.dataset.f=f; sq.id=`sq-${r}-${f}`;
      if((r===7 && document.getElementById('showCoords').checked) || (f===0 && document.getElementById('showCoords').checked)){
        const small=document.createElement('div');
        small.style.fontSize='11px'; small.style.position='absolute'; small.style.left='6px'; small.style.top='6px'; small.style.color='rgba(0,0,0,0.2)';
        small.innerText = algebraic(r,f);
        sq.appendChild(small);
      }
      const p = gameState.board[r][f];
      if(p){
        const span=document.createElement('div'); span.className='piece'; span.draggable=true; span.style.fontSize='34px';
        span.innerHTML = pieceToUnicode(p);
        span.dataset.p=p; span.dataset.r=r; span.dataset.f=f;
        span.addEventListener('dragstart',e=>dragStart(e,r,f));
        sq.appendChild(span);
      }
      sq.addEventListener('click',()=>onSquareClick(r,f));
      sq.addEventListener('dragover',e=>e.preventDefault());
      sq.addEventListener('drop',e=>onDrop(e,r,f));
      boardEl.appendChild(sq);
    }
  }
  // highlight last move
  lastMoveHighlight.forEach(a=>{ const el=document.getElementById(`sq-${a[0]}-${a[1]}`); if(el) el.classList.add('last-move'); });
  if(selected){
    const sqSel = document.getElementById(`sq-${selected.r}-${selected.f}`);
    if(sqSel) sqSel.classList.add('highlight');
    const moves = generateLegalMovesForSquare(selected.r, selected.f);
    for(const mv of moves){ const e=document.getElementById(`sq-${mv.to[0]}-${mv.to[1]}`); if(e) e.classList.add('highlight'); }
  }
  turnLabel.innerText = gameState.turn === 'w' ? 'White to move' : 'Black to move';
}

function pieceToUnicode(p){
  const map = {P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔', p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚'};
  return map[p]||p;
}

// --- Drag/drop & moves (mostly same as original)
function dragStart(e,r,f){ selected={r,f}; setStatus('Piece selected'); renderBoard(); }
function onDrop(e,r,f){ if(!selected) return; tryMakeMove(selected.r, selected.f, r, f); selected=null; renderBoard(); }
function onSquareClick(r,f){ const p = gameState.board[r][f]; if(selected && selected.r===r && selected.f===f){ selected=null; renderBoard(); return; }
  if(selected){ tryMakeMove(selected.r, selected.f, r, f); selected=null; renderBoard(); return; }
  if(p && ((p===p.toUpperCase() && gameState.turn==='w') || (p===p.toLowerCase() && gameState.turn==='b'))){ selected={r,f}; setStatus('Selected '+p); renderBoard(); }
}

function generateLegalMovesForSquare(r,f){
  const p = gameState.board[r][f]; if(!p) return [];
  const color = (p===p.toUpperCase()) ? 'w':'b'; if(color!==gameState.turn) return [];
  let moves = generatePseudoMoves(r,f,p);
  const legal = moves.filter(mv=>{
    const snapshot = saveStateForTest();
    makeMoveInternal(mv);
    const ok = !isKingInCheck(color);
    restoreStateFromTest(snapshot);
    return ok;
  });
  return legal;
}

function generateAllLegalMoves(color){
  let out=[];
  for(let r=0;r<8;r++) for(let f=0;f<8;f++){
    const p = gameState.board[r][f]; if(!p) continue;
    const c = p===p.toUpperCase()?'w':'b'; if(c!==color) continue;
    const moves = generateLegalMovesForSquare(r,f);
    for(const mv of moves) out.push(mv);
  }
  return out;
}

function generatePseudoMoves(r,f,p){
  const moves=[];
  const color = p===p.toUpperCase() ? 'w':'b';
  const dir = (color==='w') ? -1:1;
  const opp = color==='w'?'b':'w';
  const isUpper = p===p.toUpperCase();
  const lowerP = p.toLowerCase();
  if(lowerP==='p'){
    const r1 = r+dir;
    if(inBounds(r1,f) && !gameState.board[r1][f]){
      moves.push({from:[r,f],to:[r1,f],piece:p,type:'move'});
      const startRow = color==='w'?6:1;
      if(r===startRow){ const r2=r+dir*2; if(!gameState.board[r2][f]) moves.push({from:[r,f],to:[r2,f],piece:p,type:'double'}); }
    }
    for(const df of [-1,1]){
      const rf = r+dir, ff=f+df;
      if(inBounds(rf,ff)){
        const target = gameState.board[rf][ff];
        if(target && ((target===target.toUpperCase() && color==='b') || (target===target.toLowerCase() && color==='w'))){
          moves.push({from:[r,f],to:[rf,ff],piece:p,type:'capture'});
        }
      }
    }
    if(gameState.ep){
      const ep = fromAlg(gameState.ep);
      if(Math.abs(ep[1]-f)===1 && ep[0]===r+dir){ moves.push({from:[r,f],to:[ep[0],ep[1]],piece:p,type:'enpassant'}); }
    }
  }
  else if(lowerP==='n'){
    const dirs=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
    for(const d of dirs){ const rr=r+d[0], ff=f+d[1]; if(inBounds(rr,ff) && !isOwn(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:isEnemy(rr,ff,color)?'capture':'move'}); }
  }
  else if(lowerP==='b' || lowerP==='r' || lowerP==='q'){
    const vectors = [];
    if(lowerP==='b' || lowerP==='q') vectors.push(...[[1,1],[1,-1],[-1,1],[-1,-1]]);
    if(lowerP==='r' || lowerP==='q') vectors.push(...[[1,0],[-1,0],[0,1],[0,-1]]);
    for(const v of vectors){
      let rr=r+v[0], ff=f+v[1];
      while(inBounds(rr,ff)){
        if(!gameState.board[rr][ff]){ moves.push({from:[r,f],to:[rr,ff],piece:p,type:'move'}); }
        else { if(isEnemy(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:'capture'}); break; }
        rr+=v[0]; ff+=v[1];
      }
    }
  }
  else if(lowerP==='k'){
    for(let dr=-1;dr<=1;dr++) for(let df=-1;df<=1;df++){ if(dr===0 && df===0) continue; const rr=r+dr, ff=f+df; if(inBounds(rr,ff) && !isOwn(rr,ff,color)) moves.push({from:[r,f],to:[rr,ff],piece:p,type:isEnemy(rr,ff,color)?'capture':'move'}); }
    if(color==='w'){
      if(gameState.castling && gameState.castling.includes('K')){
        if(!gameState.board[7][5] && !gameState.board[7][6]) moves.push({from:[7,4],to:[7,6],piece:p,type:'castleK'});
      }
      if(gameState.castling && gameState.castling.includes('Q')){
        if(!gameState.board[7][1] && !gameState.board[7][2] && !gameState.board[7][3]) moves.push({from:[7,4],to:[7,2],piece:p,type:'castleQ'});
      }
    } else {
      if(gameState.castling && gameState.castling.includes('k')){
        if(!gameState.board[0][5] && !gameState.board[0][6]) moves.push({from:[0,4],to:[0,6],piece:p,type:'castleK'});
      }
      if(gameState.castling && gameState.castling.includes('q')){
        if(!gameState.board[0][1] && !gameState.board[0][2] && !gameState.board[0][3]) moves.push({from:[0,4],to:[0,2],piece:p,type:'castleQ'});
      }
    }
  }
  return moves;
}

function inBounds(r,f){ return r>=0 && r<8 && f>=0 && f<8; }
function isOwn(r,f,color){ const t=gameState.board[r][f]; if(!t) return false; return (t===t.toUpperCase() && color==='w') || (t===t.toLowerCase() && color==='b'); }
function isEnemy(r,f,color){ const t=gameState.board[r][f]; if(!t) return false; return (t===t.toUpperCase() && color==='b') || (t===t.toLowerCase() && color==='w'); }

function tryMakeMove(r1,f1,r2,f2){
  const p = gameState.board[r1][f1]; if(!p) return false;
  const moves = generateLegalMovesForSquare(r1,f1);
  const mv = moves.find(m=>m.to[0]===r2 && m.to[1]===f2);
  if(!mv){ setStatus('Illegal move'); return false; }
  if(mv.piece.toLowerCase()==='p' && (r2===0 || r2===7)){
    showPromotionChooser(mv, chosen=>{ makeMove(mv, chosen); });
  } else {
    makeMove(mv);
  }
  return true;
}

// --- SAN-ish naming helper (simple)
// produces simple SAN-like names: e4, exd5, Nf3, Nxf3, O-O, O-O-O, e8=Q etc.
// This is simplified (no disambiguation), enough for labeling snapshots per requirement A.
function simpleMoveName(mv, promotionChoice){
  if(!mv) return 'start';
  if(mv.type==='castleK') return 'O-O';
  if(mv.type==='castleQ') return 'O-O-O';
  const toAlg = algebraic(mv.to[0], mv.to[1]);
  const piece = mv.piece;
  const lower = piece.toLowerCase();
  const isPawn = lower==='p';
  // detect capture: if target occupied or enpassant
  let isCap = mv.type==='capture' || mv.type==='enpassant';
  // For normal capture detection, check current gameState (moveHistory push occurs after calling this).
  if(!isCap){
    const target = gameState.board[mv.to[0]] && gameState.board[mv.to[0]][mv.to[1]];
    if(target) isCap = true;
  }
  if(isPawn){
    // pawn move: either 'exd5' or 'e4'
    const fromFile = 'abcdefgh'[mv.from[1]];
    if(isCap) return `${fromFile}x${toAlg}` + (mv.type==='enpassant' ? ' ep' : '') + (promotionChoice? '='+promotionChoice.toUpperCase() : '');
    else return `${toAlg}` + (promotionChoice? '='+promotionChoice.toUpperCase() : '');
  } else {
    const pieceLetter = piece.toUpperCase();
    return (isCap? pieceLetter + 'x' + toAlg : pieceLetter + toAlg) + (promotionChoice? '='+promotionChoice.toUpperCase() : '');
  }
}

// --- makeMove: push history, compute move name, then apply
function makeMove(mv, promotionChoice){
  // compute simple SAN name using present gameState (which is pre-move)
  const computedName = simpleMoveName(mv, promotionChoice);
  // push history
  const hist = {state:deepClone(gameState), mv: deepClone(mv)};
  moveHistory.push(hist);
  // apply move
  makeMoveInternal(mv, promotionChoice);
  // update last move highlight
  lastMoveHighlight = [mv.from, mv.to];
  renderMoves();
  renderBoard();
}

// Internal apply (same as original)
function makeMoveInternal(mv, promotionChoice){
  const [r1,f1]=mv.from; const [r2,f2]=mv.to; const p = gameState.board[r1][f1];
  if(mv.type==='enpassant'){
    const capR = r1; const capF = f2;
    gameState.board[capR][capF]=null;
  }
  if(mv.type==='castleK'){
    if(gameState.turn==='w'){
      gameState.board[7][6]=gameState.board[7][4]; gameState.board[7][4]=null;
      gameState.board[7][5]=gameState.board[7][7]; gameState.board[7][7]=null;
    } else {
      gameState.board[0][6]=gameState.board[0][4]; gameState.board[0][4]=null;
      gameState.board[0][5]=gameState.board[0][7]; gameState.board[0][7]=null;
    }
    if(gameState.turn==='w') gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
    gameState.ep=null; gameState.turn = gameState.turn==='w'?'b':'w'; return;
  }
  if(mv.type==='castleQ'){
    if(gameState.turn==='w'){
      gameState.board[7][2]=gameState.board[7][4]; gameState.board[7][4]=null;
      gameState.board[7][3]=gameState.board[7][0]; gameState.board[7][0]=null;
    } else {
      gameState.board[0][2]=gameState.board[0][4]; gameState.board[0][4]=null;
      gameState.board[0][3]=gameState.board[0][0]; gameState.board[0][0]=null;
    }
    if(gameState.turn==='w') gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
    gameState.ep=null; gameState.turn = gameState.turn==='w'?'b':'w'; return;
  }
  gameState.board[r2][f2] = gameState.board[r1][f1]; gameState.board[r1][f1]=null;
  if(mv.type==='double'){
    const epR = (r1 + r2)/2; gameState.ep = algebraic(epR,f1);
  } else {
    gameState.ep = null;
  }
  if(p.toLowerCase()==='p' && (r2===0 || r2===7)){
    const make = promotionChoice||'q';
    const color = p===p.toUpperCase()?'w':'b';
    const pieceChar = color==='w'?make.toUpperCase():make.toLowerCase();
    gameState.board[r2][f2] = pieceChar;
  }
  if(p.toLowerCase()==='k'){
    if(p===p.toUpperCase()) gameState.castling = gameState.castling.replace('K','').replace('Q',''); else gameState.castling = gameState.castling.replace('k','').replace('q','');
  }
  if(p.toLowerCase()==='r'){
    if(r1===7 && f1===0) gameState.castling = gameState.castling.replace('Q','');
    if(r1===7 && f1===7) gameState.castling = gameState.castling.replace('K','');
    if(r1===0 && f1===0) gameState.castling = gameState.castling.replace('q','');
    if(r1===0 && f1===7) gameState.castling = gameState.castling.replace('k','');
  }
  if(mv.type==='capture'){
    if(r2===7 && f2===0) gameState.castling = gameState.castling.replace('Q','');
    if(r2===7 && f2===7) gameState.castling = gameState.castling.replace('K','');
    if(r2===0 && f2===0) gameState.castling = gameState.castling.replace('q','');
    if(r2===0 && f2===7) gameState.castling = gameState.castling.replace('k','');
  }
  gameState.turn = gameState.turn==='w'?'b':'w';
}

function saveStateForTest(){ return deepClone(gameState); }
function restoreStateFromTest(s){ gameState = s; }

function isKingInCheck(color){
  let kr=-1,kf=-1; for(let r=0;r<8;r++) for(let f=0;f<8;f++){ const p=gameState.board[r][f]; if(p && ((p==='K' && color==='w') || (p==='k' && color==='b'))){ kr=r;kf=f; } }
  if(kr===-1) return true;
  const enemy = color==='w'?'b':'w';
  const pd = color==='w'?-1:1;
  for(const df of [-1,1]){
    const rr=kr+pd, ff=kf+df; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && ((t==='p' && enemy==='b') || (t==='P' && enemy==='w'))) return true; }
  }
  const ndirs=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  for(const d of ndirs){ const rr=kr+d[0], ff=kf+d[1]; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && (t.toLowerCase()==='n') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; } }
  const rays = {rook:[[1,0],[-1,0],[0,1],[0,-1]], bishop:[[1,1],[1,-1],[-1,1],[-1,-1]] };
  for(const v of rays.rook){ let rr=kr+v[0], ff=kf+v[1]; while(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t){ if((t.toLowerCase()==='r' || t.toLowerCase()==='q') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; else break; } rr+=v[0]; ff+=v[1]; } }
  for(const v of rays.bishop){ let rr=kr+v[0], ff=kf+v[1]; while(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t){ if((t.toLowerCase()==='b' || t.toLowerCase()==='q') && ((t===t.toUpperCase())=== (enemy==='w'))) return true; else break; } rr+=v[0]; ff+=v[1]; } }
  for(let dr=-1;dr<=1;dr++) for(let df=-1;df<=1;df++){ if(dr===0&&df===0) continue; const rr=kr+dr, ff=kf+df; if(inBounds(rr,ff)){ const t=gameState.board[rr][ff]; if(t && t.toLowerCase()==='k' && ((t===t.toUpperCase())=== (enemy==='w'))) return true; } }
  return false;
}

// --- UI helpers
function setStatus(s){ statusLabel.innerText = s; }

function renderMoves(){ movesList.innerHTML=''; for(let i=0;i<moveHistory.length;i++){ const mv = moveHistory[i].mv; const from=algebraic(mv.from[0],mv.from[1]); const to=algebraic(mv.to[0],mv.to[1]); const el=document.createElement('div'); el.innerText = (i+1)+'. '+from+'-'+to+' '+(mv.type||''); movesList.appendChild(el); } }

// Undo/Reset
document.getElementById('undoBtn').addEventListener('click',()=>{ if(moveHistory.length===0) return; const last = moveHistory.pop(); gameState = last.state; lastMoveHighlight = []; renderMoves(); renderBoard(); });
document.getElementById('resetBtn').addEventListener('click',()=>{ gameState = fenToBoard(initialFEN); moveHistory=[]; lastMoveHighlight=[]; renderMoves(); renderBoard(); });

// Options
document.getElementById('legalOnly').addEventListener('change',e=>{ legalOnly = e.target.checked; });
document.getElementById('showCoords').addEventListener('change',e=>{ renderBoard(); });

// Promotion modal
let promotionCallback=null; function showPromotionChooser(mv, cb){ promotionCallback = cb; const pb = document.getElementById('promoButtons'); pb.innerHTML=''; ['q','r','b','n'].forEach(p=>{ const b=document.createElement('button'); b.className='btn'; b.innerText = p.toUpperCase(); b.addEventListener('click',()=>{ hidePromotion(); cb(p); }); pb.appendChild(b); }); document.getElementById('promotionModal').style.display='block'; }
function hidePromotion(){ document.getElementById('promotionModal').style.display='none'; promotionCallback=null; }
document.getElementById('promoCancel').addEventListener('click',()=>{ hidePromotion(); });

// --- Saving snapshots & node graph (rewritten per request)

// DOM refs
const saveCanvas = document.getElementById('saveCanvas');
const connectionsSVG = document.getElementById('connections');
let saves = loadSaves(); let selectedNodeId = null;
let baseNodeId = null; // the 'Set Base' node id
renderSaves();

// Save snapshot: create node, automatically attach under base lineage if base set
function saveCurrentSnapshot(){
  const fen = boardToFEN(gameState);
  const ts = Date.now();
  const id = 'n'+ts;
  // compute default name: last move name (option A)
  let name = 'start';
  if(moveHistory.length>0){
    // last entry in moveHistory corresponds to the move just made before current state.
    const lastHist = moveHistory[moveHistory.length-1];
    const lastMv = lastHist.mv;
    // We don't have promotionChoice in history; attempt to detect promotion by checking board at mv.to
    let promotionChoice = null;
    // if piece on destination is not pawn and original was pawn, treat as promotion
    try{
      const destPiece = gameState.board[lastMv.to[0]][lastMv.to[1]];
      if(destPiece && destPiece.toLowerCase()!=='p' && lastMv.piece.toLowerCase()==='p') promotionChoice = destPiece.toUpperCase();
    }catch(e){}
    name = simpleMoveName(lastMv, promotionChoice);
  }
  // create node object
  const node = {id, name, fen, x:20 + (Object.keys(saves).length%6)*120, y:20 + Math.floor(Object.keys(saves).length/6)*80, parent:null, created:ts, children:[]};
  // attach to base lineage if baseNodeId set
  if(baseNodeId && saves[baseNodeId]){
    // find the most recent descendant in that base tree (by created timestamp)
    const candidates = [];
    for(const k in saves){
      // walk up parent chain to see if baseNodeId is ancestor or equals
      let cur = saves[k];
      while(cur){
        if(cur.id === baseNodeId){ candidates.push(saves[k]); break; }
        if(!cur.parent) break;
        cur = saves[cur.parent];
      }
    }
    // choose the candidate with max created timestamp; if none, parent=baseNodeId
    if(candidates.length>0){
      candidates.sort((a,b)=>b.created - a.created);
      node.parent = candidates[0].id;
      saves[candidates[0].id].children = saves[candidates[0].id].children || [];
      saves[candidates[0].id].children.push(id);
    } else {
      node.parent = baseNodeId;
      saves[baseNodeId].children = saves[baseNodeId].children || [];
      saves[baseNodeId].children.push(id);
    }
  }
  // if no base, parent remains null (root)
  saves[id]=node;
  persistSaves();
  renderSaves();
}
document.getElementById('saveBtn').addEventListener('click',saveCurrentSnapshot);
document.getElementById('clearSaves').addEventListener('click',()=>{ if(confirm('Clear all saves?')){ saves={}; baseNodeId=null; selectedNodeId=null; persistSaves(); renderSaves(); }});

// Rename selected node (user can still rename)
document.getElementById('renameNode').addEventListener('click',()=>{
  if(!selectedNodeId) return alert('Select a node first by clicking it'); const name = document.getElementById('nodeName').value.trim(); if(!name) return alert('Provide a name'); saves[selectedNodeId].name=name; persistSaves(); renderSaves();
});

// Set / clear base
document.getElementById('setBaseBtn').addEventListener('click',()=>{
  if(!selectedNodeId) return alert('Select a node to be base first');
  baseNodeId = selectedNodeId;
  updateBaseIndicator();
});
document.getElementById('clearBaseBtn').addEventListener('click',()=>{
  baseNodeId = null; updateBaseIndicator();
});
function updateBaseIndicator(){
  const el = document.getElementById('baseIndicator');
  const nameEl = document.getElementById('baseName');
  if(baseNodeId && saves[baseNodeId]){ el.style.display='inline'; nameEl.innerText = saves[baseNodeId].name; } else { el.style.display='none'; nameEl.innerText=''; }
}

function persistSaves(){ localStorage.setItem('chess_saves', JSON.stringify(saves)); }
function loadSaves(){ try{ return JSON.parse(localStorage.getItem('chess_saves')||'{}'); }catch(e){return{}} }

function renderSaves(){ saveCanvas.innerHTML=''; saveCanvas.appendChild(connectionsSVG);
  // create node elems
  for(const id in saves){
    const node=saves[id];
    const el=document.createElement('div'); el.className='node'; el.style.left=node.x+'px'; el.style.top=node.y+'px'; el.id='node-'+id;
    // show only the move name (no raw id)
    el.innerHTML = `<div class="title">${node.name}</div><div style="margin-top:6px;font-size:12px;color:#666">${node.fen.split(' ')[1]==='w'?'White':'Black'} to move</div>`;
    el.addEventListener('mousedown',startDragNode(id));
    el.addEventListener('click',e=>{ e.stopPropagation(); selectNode(id); });
    saveCanvas.appendChild(el);
  }
  drawConnections();
  updateBaseIndicator();
}

function selectNode(id){ selectedNodeId=id; document.getElementById('nodeName').value = saves[id].name; // load snapshot
  const fen = saves[id].fen; gameState = fenToBoard(fen); moveHistory=[]; lastMoveHighlight=[]; renderBoard(); }

// Drag node
let dragInfo=null;
function startDragNode(id){ return function(e){ e.preventDefault(); dragInfo={id,ox:e.clientX,oy:e.clientY,startX:saves[id].x,startY:saves[id].y}; document.addEventListener('mousemove',onDragNode); document.addEventListener('mouseup',stopDragNode); } }
function onDragNode(e){ if(!dragInfo) return; const dx=e.clientX-dragInfo.ox, dy=e.clientY-dragInfo.oy; saves[dragInfo.id].x = dragInfo.startX + dx; saves[dragInfo.id].y = dragInfo.startY + dy; persistSaves(); renderSaves(); }
function stopDragNode(e){ dragInfo=null; document.removeEventListener('mousemove',onDragNode); document.removeEventListener('mouseup',stopDragNode); }

// clicking empty area deselect
saveCanvas.addEventListener('click',()=>{ selectedNodeId=null; document.getElementById('nodeName').value=''; });

// draw connections by parent -> child
function drawConnections(){ connectionsSVG.innerHTML=''; const rect = saveCanvas.getBoundingClientRect();
  for(const id in saves){
    const node=saves[id];
    if(node.parent){
      const parent = saves[node.parent];
      if(!parent) continue;
      const x1 = parent.x + 80, y1 = parent.y + 24;
      const x2 = node.x + 8, y2 = node.y + 24;
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d',`M ${x1} ${y1} C ${x1+40} ${y1} ${x2-40} ${y2} ${x2} ${y2}`);
      path.setAttribute('stroke','#2b6cb0'); path.setAttribute('stroke-width','2'); path.setAttribute('fill','none'); connectionsSVG.appendChild(path);
    }
  }
}

// --- small helper used for castling path safety (same as original)
function isAttacked(squareR, squareF, byColor){
  const snapshot = saveStateForTest(); const saveTurn = gameState.turn; gameState.turn = byColor; const moves = generateAllLegalMoves(byColor); gameState.turn = saveTurn; restoreStateFromTest(snapshot);
  return moves.some(m=>m.to[0]===squareR && m.to[1]===squareF);
}

// Re-render initially
renderBoard();

</script>
</body>
</html>
